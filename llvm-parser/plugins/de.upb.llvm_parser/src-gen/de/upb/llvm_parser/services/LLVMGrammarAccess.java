/*
* generated by Xtext
*/

package de.upb.llvm_parser.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class LLVMGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class LLVMElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LLVM");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsAbstractElementParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		/// *
		//
		// * This Grammer is used to parse a llvm document.
		//
		// * The llvm project itself is located at http://llvm.org
		//
		// * For a language introduction see: http://llvm.org/docs/LangRef.html
		//
		// * A list of guides can be found on: http://llvm.org/docs/userguides.html
		//
		// * / LLVM:
		//
		//	elements+=AbstractElement*;
		public ParserRule getRule() { return rule; }

		//elements+=AbstractElement*
		public Assignment getElementsAssignment() { return cElementsAssignment; }

		//AbstractElement
		public RuleCall getElementsAbstractElementParserRuleCall_0() { return cElementsAbstractElementParserRuleCall_0; }
	}

	public class AbstractElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbstractElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cTopLevelEntityParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cSL_COMMENTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cMainLevelEntityParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cSL_COMMENTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		/// *
		//
		// * An Abstract Element is either a TopLevelEntity, used for the predefinitions of the llvm-code
		//
		// * or a MainLevelEntity, which are basically functiondefinitions. 
		//
		// * / AbstractElement:
		//
		//	TopLevelEntity SL_COMMENT? | MainLevelEntity SL_COMMENT?;
		public ParserRule getRule() { return rule; }

		//TopLevelEntity SL_COMMENT? | MainLevelEntity SL_COMMENT?
		public Alternatives getAlternatives() { return cAlternatives; }

		//TopLevelEntity SL_COMMENT?
		public Group getGroup_0() { return cGroup_0; }

		//TopLevelEntity
		public RuleCall getTopLevelEntityParserRuleCall_0_0() { return cTopLevelEntityParserRuleCall_0_0; }

		//SL_COMMENT?
		public RuleCall getSL_COMMENTTerminalRuleCall_0_1() { return cSL_COMMENTTerminalRuleCall_0_1; }

		//MainLevelEntity SL_COMMENT?
		public Group getGroup_1() { return cGroup_1; }

		//MainLevelEntity
		public RuleCall getMainLevelEntityParserRuleCall_1_0() { return cMainLevelEntityParserRuleCall_1_0; }

		//SL_COMMENT?
		public RuleCall getSL_COMMENTTerminalRuleCall_1_1() { return cSL_COMMENTTerminalRuleCall_1_1; }
	}

	public class TopLevelEntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TopLevelEntity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cModuleKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cAsmKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cModuleAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cModuleSTRINGTerminalRuleCall_0_2_0 = (RuleCall)cModuleAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cTargetKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cDatalayoutKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cTripleKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cTargetAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cTargetSTRINGTerminalRuleCall_1_3_0 = (RuleCall)cTargetAssignment_1_3.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cDeplibsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cLibsAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cLibsSTRINGTerminalRuleCall_2_3_0 = (RuleCall)cLibsAssignment_2_3.eContents().get(0);
		private final Group cGroup_2_4 = (Group)cGroup_2.eContents().get(4);
		private final Keyword cCommaKeyword_2_4_0 = (Keyword)cGroup_2_4.eContents().get(0);
		private final Assignment cLibsAssignment_2_4_1 = (Assignment)cGroup_2_4.eContents().get(1);
		private final RuleCall cLibsSTRINGTerminalRuleCall_2_4_1_0 = (RuleCall)cLibsAssignment_2_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_5 = (Keyword)cGroup_2.eContents().get(5);
		
		/// *
		//
		// * Predefinitions of the llvm-code
		//
		// * / TopLevelEntity:
		//
		//	"module" "asm" module=STRING | "target" ("datalayout" | "triple") "=" target=STRING | "deplibs" "=" "[" libs+=STRING
		//
		//	("," libs+=STRING)* "]";
		public ParserRule getRule() { return rule; }

		//"module" "asm" module=STRING | "target" ("datalayout" | "triple") "=" target=STRING | "deplibs" "=" "[" libs+=STRING
		//
		//("," libs+=STRING)* "]"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"module" "asm" module=STRING
		public Group getGroup_0() { return cGroup_0; }

		//"module"
		public Keyword getModuleKeyword_0_0() { return cModuleKeyword_0_0; }

		//"asm"
		public Keyword getAsmKeyword_0_1() { return cAsmKeyword_0_1; }

		//module=STRING
		public Assignment getModuleAssignment_0_2() { return cModuleAssignment_0_2; }

		//STRING
		public RuleCall getModuleSTRINGTerminalRuleCall_0_2_0() { return cModuleSTRINGTerminalRuleCall_0_2_0; }

		//"target" ("datalayout" | "triple") "=" target=STRING
		public Group getGroup_1() { return cGroup_1; }

		//"target"
		public Keyword getTargetKeyword_1_0() { return cTargetKeyword_1_0; }

		//"datalayout" | "triple"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"datalayout"
		public Keyword getDatalayoutKeyword_1_1_0() { return cDatalayoutKeyword_1_1_0; }

		//"triple"
		public Keyword getTripleKeyword_1_1_1() { return cTripleKeyword_1_1_1; }

		//"="
		public Keyword getEqualsSignKeyword_1_2() { return cEqualsSignKeyword_1_2; }

		//target=STRING
		public Assignment getTargetAssignment_1_3() { return cTargetAssignment_1_3; }

		//STRING
		public RuleCall getTargetSTRINGTerminalRuleCall_1_3_0() { return cTargetSTRINGTerminalRuleCall_1_3_0; }

		//"deplibs" "=" "[" libs+=STRING ("," libs+=STRING)* "]"
		public Group getGroup_2() { return cGroup_2; }

		//"deplibs"
		public Keyword getDeplibsKeyword_2_0() { return cDeplibsKeyword_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_1() { return cEqualsSignKeyword_2_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2_2() { return cLeftSquareBracketKeyword_2_2; }

		//libs+=STRING
		public Assignment getLibsAssignment_2_3() { return cLibsAssignment_2_3; }

		//STRING
		public RuleCall getLibsSTRINGTerminalRuleCall_2_3_0() { return cLibsSTRINGTerminalRuleCall_2_3_0; }

		//("," libs+=STRING)*
		public Group getGroup_2_4() { return cGroup_2_4; }

		//","
		public Keyword getCommaKeyword_2_4_0() { return cCommaKeyword_2_4_0; }

		//libs+=STRING
		public Assignment getLibsAssignment_2_4_1() { return cLibsAssignment_2_4_1; }

		//STRING
		public RuleCall getLibsSTRINGTerminalRuleCall_2_4_1_0() { return cLibsSTRINGTerminalRuleCall_2_4_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2_5() { return cRightSquareBracketKeyword_2_5; }
	}

	public class MainLevelEntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MainLevelEntity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunctionHeaderParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLocalVarParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		//
		// * This rule is used to devide the Function Definitions form the Variable Definitions.
		//
		// * / MainLevelEntity:
		//
		//	FunctionHeader | LocalVar;
		public ParserRule getRule() { return rule; }

		//FunctionHeader | LocalVar
		public Alternatives getAlternatives() { return cAlternatives; }

		//FunctionHeader
		public RuleCall getFunctionHeaderParserRuleCall_0() { return cFunctionHeaderParserRuleCall_0; }

		//LocalVar
		public RuleCall getLocalVarParserRuleCall_1() { return cLocalVarParserRuleCall_1; }
	}

	public class FunctionHeaderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionHeader");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cDefineKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cLINKAGEParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cVISIBILITYParserRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final RuleCall cCallingConvParserRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_0_4 = (RuleCall)cGroup_0.eContents().get(4);
		private final Assignment cReturnTypeAssignment_0_5 = (Assignment)cGroup_0.eContents().get(5);
		private final RuleCall cReturnTypeTypeParserRuleCall_0_5_0 = (RuleCall)cReturnTypeAssignment_0_5.eContents().get(0);
		private final Assignment cNameAssignment_0_6 = (Assignment)cGroup_0.eContents().get(6);
		private final RuleCall cNameVAR_TYPETerminalRuleCall_0_6_0 = (RuleCall)cNameAssignment_0_6.eContents().get(0);
		private final Assignment cPlAssignment_0_7 = (Assignment)cGroup_0.eContents().get(7);
		private final RuleCall cPlParameterListParserRuleCall_0_7_0 = (RuleCall)cPlAssignment_0_7.eContents().get(0);
		private final Keyword cUnnamed_addrKeyword_0_8 = (Keyword)cGroup_0.eContents().get(8);
		private final RuleCall cFUNCTION_ATTRIBUTESParserRuleCall_0_9 = (RuleCall)cGroup_0.eContents().get(9);
		private final Group cGroup_0_10 = (Group)cGroup_0.eContents().get(10);
		private final Keyword cSectionKeyword_0_10_0 = (Keyword)cGroup_0_10.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_0_10_1 = (RuleCall)cGroup_0_10.eContents().get(1);
		private final RuleCall cALIGNMENTParserRuleCall_0_11 = (RuleCall)cGroup_0.eContents().get(11);
		private final Assignment cBodyAssignment_0_12 = (Assignment)cGroup_0.eContents().get(12);
		private final RuleCall cBodyFunctionBodyParserRuleCall_0_12_0 = (RuleCall)cBodyAssignment_0_12.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cDeclareKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cLINKAGEParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cVISIBILITYParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final RuleCall cCallingConvParserRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		private final Assignment cReturnTypeAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cReturnTypeTypeParserRuleCall_1_5_0 = (RuleCall)cReturnTypeAssignment_1_5.eContents().get(0);
		private final Assignment cNameAssignment_1_6 = (Assignment)cGroup_1.eContents().get(6);
		private final RuleCall cNameVAR_TYPETerminalRuleCall_1_6_0 = (RuleCall)cNameAssignment_1_6.eContents().get(0);
		private final Alternatives cAlternatives_1_7 = (Alternatives)cGroup_1.eContents().get(7);
		private final Assignment cTListAssignment_1_7_0 = (Assignment)cAlternatives_1_7.eContents().get(0);
		private final RuleCall cTListTypeListParserRuleCall_1_7_0_0 = (RuleCall)cTListAssignment_1_7_0.eContents().get(0);
		private final Keyword cLeftParenthesisFullStopFullStopFullStopRightParenthesisKeyword_1_7_1 = (Keyword)cAlternatives_1_7.eContents().get(1);
		private final Keyword cUnnamed_addrKeyword_1_8 = (Keyword)cGroup_1.eContents().get(8);
		private final RuleCall cFUNCTION_ATTRIBUTESParserRuleCall_1_9 = (RuleCall)cGroup_1.eContents().get(9);
		private final Group cGroup_1_10 = (Group)cGroup_1.eContents().get(10);
		private final Keyword cSectionKeyword_1_10_0 = (Keyword)cGroup_1_10.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_1_10_1 = (RuleCall)cGroup_1_10.eContents().get(1);
		private final RuleCall cALIGNMENTParserRuleCall_1_11 = (RuleCall)cGroup_1.eContents().get(11);
		
		/// *
		//
		// * A Function Header has to be defined or declared.
		//
		// * If a function is declared, there will be no function body, and also the parameterlist needn't to be defined
		//
		// * Example: 
		//
		// *  declare i32 @__gxx_personality_v0(...)
		//
		// * If a function is defined, there are multiple optional parameters such as visibility or return attributes.
		//
		// * Example:
		//
		// *  define linkonce_odr void @_ZN4NodeC1Ev(%class.Node* %this) unnamed_addr align 2 { ... }
		//
		// * / FunctionHeader:
		//
		//	"define" LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=Type name=VAR_TYPE pl=ParameterList
		//
		//	"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT? body=FunctionBody | "declare" LINKAGE?
		//
		//	VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=Type name=VAR_TYPE (tList=TypeList | "(...)") "unnamed_addr"?
		//
		//	FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT?;
		public ParserRule getRule() { return rule; }

		//"define" LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=Type name=VAR_TYPE pl=ParameterList
		//
		//"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT? body=FunctionBody | "declare" LINKAGE?
		//
		//VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=Type name=VAR_TYPE (tList=TypeList | "(...)") "unnamed_addr"?
		//
		//FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT?
		public Alternatives getAlternatives() { return cAlternatives; }

		//"define" LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=Type name=VAR_TYPE pl=ParameterList
		//
		//"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT? body=FunctionBody
		public Group getGroup_0() { return cGroup_0; }

		//"define"
		public Keyword getDefineKeyword_0_0() { return cDefineKeyword_0_0; }

		//LINKAGE?
		public RuleCall getLINKAGEParserRuleCall_0_1() { return cLINKAGEParserRuleCall_0_1; }

		//VISIBILITY?
		public RuleCall getVISIBILITYParserRuleCall_0_2() { return cVISIBILITYParserRuleCall_0_2; }

		//CallingConv?
		public RuleCall getCallingConvParserRuleCall_0_3() { return cCallingConvParserRuleCall_0_3; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_0_4() { return cRETURN_ATTRIBUTESParserRuleCall_0_4; }

		//returnType=Type
		public Assignment getReturnTypeAssignment_0_5() { return cReturnTypeAssignment_0_5; }

		//Type
		public RuleCall getReturnTypeTypeParserRuleCall_0_5_0() { return cReturnTypeTypeParserRuleCall_0_5_0; }

		//name=VAR_TYPE
		public Assignment getNameAssignment_0_6() { return cNameAssignment_0_6; }

		//VAR_TYPE
		public RuleCall getNameVAR_TYPETerminalRuleCall_0_6_0() { return cNameVAR_TYPETerminalRuleCall_0_6_0; }

		//pl=ParameterList
		public Assignment getPlAssignment_0_7() { return cPlAssignment_0_7; }

		//ParameterList
		public RuleCall getPlParameterListParserRuleCall_0_7_0() { return cPlParameterListParserRuleCall_0_7_0; }

		//"unnamed_addr"?
		public Keyword getUnnamed_addrKeyword_0_8() { return cUnnamed_addrKeyword_0_8; }

		//FUNCTION_ATTRIBUTES*
		public RuleCall getFUNCTION_ATTRIBUTESParserRuleCall_0_9() { return cFUNCTION_ATTRIBUTESParserRuleCall_0_9; }

		//("section " STRING)?
		public Group getGroup_0_10() { return cGroup_0_10; }

		//"section "
		public Keyword getSectionKeyword_0_10_0() { return cSectionKeyword_0_10_0; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0_10_1() { return cSTRINGTerminalRuleCall_0_10_1; }

		//ALIGNMENT?
		public RuleCall getALIGNMENTParserRuleCall_0_11() { return cALIGNMENTParserRuleCall_0_11; }

		//body=FunctionBody
		public Assignment getBodyAssignment_0_12() { return cBodyAssignment_0_12; }

		//FunctionBody
		public RuleCall getBodyFunctionBodyParserRuleCall_0_12_0() { return cBodyFunctionBodyParserRuleCall_0_12_0; }

		//"declare" LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=Type name=VAR_TYPE (tList=TypeList | "(...)")
		//
		//"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT?
		public Group getGroup_1() { return cGroup_1; }

		//"declare"
		public Keyword getDeclareKeyword_1_0() { return cDeclareKeyword_1_0; }

		//LINKAGE?
		public RuleCall getLINKAGEParserRuleCall_1_1() { return cLINKAGEParserRuleCall_1_1; }

		//VISIBILITY?
		public RuleCall getVISIBILITYParserRuleCall_1_2() { return cVISIBILITYParserRuleCall_1_2; }

		//CallingConv?
		public RuleCall getCallingConvParserRuleCall_1_3() { return cCallingConvParserRuleCall_1_3; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_1_4() { return cRETURN_ATTRIBUTESParserRuleCall_1_4; }

		//returnType=Type
		public Assignment getReturnTypeAssignment_1_5() { return cReturnTypeAssignment_1_5; }

		//Type
		public RuleCall getReturnTypeTypeParserRuleCall_1_5_0() { return cReturnTypeTypeParserRuleCall_1_5_0; }

		//name=VAR_TYPE
		public Assignment getNameAssignment_1_6() { return cNameAssignment_1_6; }

		//VAR_TYPE
		public RuleCall getNameVAR_TYPETerminalRuleCall_1_6_0() { return cNameVAR_TYPETerminalRuleCall_1_6_0; }

		//tList=TypeList | "(...)"
		public Alternatives getAlternatives_1_7() { return cAlternatives_1_7; }

		//tList=TypeList
		public Assignment getTListAssignment_1_7_0() { return cTListAssignment_1_7_0; }

		//TypeList
		public RuleCall getTListTypeListParserRuleCall_1_7_0_0() { return cTListTypeListParserRuleCall_1_7_0_0; }

		//"(...)"
		public Keyword getLeftParenthesisFullStopFullStopFullStopRightParenthesisKeyword_1_7_1() { return cLeftParenthesisFullStopFullStopFullStopRightParenthesisKeyword_1_7_1; }

		//"unnamed_addr"?
		public Keyword getUnnamed_addrKeyword_1_8() { return cUnnamed_addrKeyword_1_8; }

		//FUNCTION_ATTRIBUTES*
		public RuleCall getFUNCTION_ATTRIBUTESParserRuleCall_1_9() { return cFUNCTION_ATTRIBUTESParserRuleCall_1_9; }

		//("section " STRING)?
		public Group getGroup_1_10() { return cGroup_1_10; }

		//"section "
		public Keyword getSectionKeyword_1_10_0() { return cSectionKeyword_1_10_0; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1_10_1() { return cSTRINGTerminalRuleCall_1_10_1; }

		//ALIGNMENT?
		public RuleCall getALIGNMENTParserRuleCall_1_11() { return cALIGNMENTParserRuleCall_1_11; }
	}

	public class ParameterListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_0 = (Alternatives)cGroup_1_0.eContents().get(0);
		private final RuleCall cVAR_TYPETerminalRuleCall_1_0_0_0 = (RuleCall)cAlternatives_1_0_0.eContents().get(0);
		private final RuleCall cB_TYPEParserRuleCall_1_0_0_1 = (RuleCall)cAlternatives_1_0_0.eContents().get(1);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_1_0_1 = (RuleCall)cGroup_1_0.eContents().get(1);
		private final RuleCall cTypeParserRuleCall_1_0_2 = (RuleCall)cGroup_1_0.eContents().get(2);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Alternatives cAlternatives_1_1_1_0 = (Alternatives)cGroup_1_1_1.eContents().get(0);
		private final RuleCall cVAR_TYPETerminalRuleCall_1_1_1_0_0 = (RuleCall)cAlternatives_1_1_1_0.eContents().get(0);
		private final RuleCall cB_TYPEParserRuleCall_1_1_1_0_1 = (RuleCall)cAlternatives_1_1_1_0.eContents().get(1);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_1_1_1_1 = (RuleCall)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cTypeParserRuleCall_1_1_1_2 = (RuleCall)cGroup_1_1_1.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		/// *
		//
		// * This rule creates a Parameterlist and saves also the TypeAndValue to each parameter 
		//
		// * / ParameterList:
		//
		//	"(" (((VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type) ("," ((VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type))*)? ")";
		public ParserRule getRule() { return rule; }

		//"(" (((VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type) ("," ((VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type))*)? ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//(((VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type) ("," ((VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type))*)?
		public Group getGroup_1() { return cGroup_1; }

		//(VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type
		public Group getGroup_1_0() { return cGroup_1_0; }

		//VAR_TYPE | B_TYPE
		public Alternatives getAlternatives_1_0_0() { return cAlternatives_1_0_0; }

		//VAR_TYPE
		public RuleCall getVAR_TYPETerminalRuleCall_1_0_0_0() { return cVAR_TYPETerminalRuleCall_1_0_0_0; }

		//B_TYPE
		public RuleCall getB_TYPEParserRuleCall_1_0_0_1() { return cB_TYPEParserRuleCall_1_0_0_1; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_1_0_1() { return cRETURN_ATTRIBUTESParserRuleCall_1_0_1; }

		//Type
		public RuleCall getTypeParserRuleCall_1_0_2() { return cTypeParserRuleCall_1_0_2; }

		//("," ((VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type))*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//(VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//VAR_TYPE | B_TYPE
		public Alternatives getAlternatives_1_1_1_0() { return cAlternatives_1_1_1_0; }

		//VAR_TYPE
		public RuleCall getVAR_TYPETerminalRuleCall_1_1_1_0_0() { return cVAR_TYPETerminalRuleCall_1_1_1_0_0; }

		//B_TYPE
		public RuleCall getB_TYPEParserRuleCall_1_1_1_0_1() { return cB_TYPEParserRuleCall_1_1_1_0_1; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_1_1_1_1() { return cRETURN_ATTRIBUTESParserRuleCall_1_1_1_1; }

		//Type
		public RuleCall getTypeParserRuleCall_1_1_1_2() { return cTypeParserRuleCall_1_1_1_2; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class TypeListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTypeListAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cTypesAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cTypesTypeParserRuleCall_2_0_0 = (RuleCall)cTypesAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cTypesAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cTypesTypeParserRuleCall_2_1_1_0 = (RuleCall)cTypesAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		//
		// * If a function is declared, the parameterlist has to be set empty or contain a List of Types.
		//
		// * / TypeList:
		//
		//	{TypeList} "(" (types+=Type ("," types+=Type)*)? ")";
		public ParserRule getRule() { return rule; }

		//{TypeList} "(" (types+=Type ("," types+=Type)*)? ")"
		public Group getGroup() { return cGroup; }

		//{TypeList}
		public Action getTypeListAction_0() { return cTypeListAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(types+=Type ("," types+=Type)*)?
		public Group getGroup_2() { return cGroup_2; }

		//types+=Type
		public Assignment getTypesAssignment_2_0() { return cTypesAssignment_2_0; }

		//Type
		public RuleCall getTypesTypeParserRuleCall_2_0_0() { return cTypesTypeParserRuleCall_2_0_0; }

		//("," types+=Type)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//types+=Type
		public Assignment getTypesAssignment_2_1_1() { return cTypesAssignment_2_1_1; }

		//Type
		public RuleCall getTypesTypeParserRuleCall_2_1_1_0() { return cTypesTypeParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class AggregateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Aggregate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAggAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAggTypeParserRuleCall_1_0 = (RuleCall)cAggAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cAggAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cAggTypeParserRuleCall_2_1_0 = (RuleCall)cAggAssignment_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		//
		// * An Aggregate is a tuple of types enclosed by curly brackets
		//
		// * / Aggregate:
		//
		//	"{" agg+=Type ("," agg+=Type) "}";
		public ParserRule getRule() { return rule; }

		//"{" agg+=Type ("," agg+=Type) "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//agg+=Type
		public Assignment getAggAssignment_1() { return cAggAssignment_1; }

		//Type
		public RuleCall getAggTypeParserRuleCall_1_0() { return cAggTypeParserRuleCall_1_0; }

		//"," agg+=Type
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//agg+=Type
		public Assignment getAggAssignment_2_1() { return cAggAssignment_2_1; }

		//Type
		public RuleCall getAggTypeParserRuleCall_2_1_0() { return cAggTypeParserRuleCall_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class LocalVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalVar");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameTypeParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cTypeKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Assignment cTypeAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_2_0_1_0 = (RuleCall)cTypeAssignment_2_0_1.eContents().get(0);
		private final Assignment cInstrAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cInstrInstructionParserRuleCall_2_1_0 = (RuleCall)cInstrAssignment_2_1.eContents().get(0);
		private final Assignment cAliasAssignment_2_2 = (Assignment)cAlternatives_2.eContents().get(2);
		private final RuleCall cAliasAliasParserRuleCall_2_2_0 = (RuleCall)cAliasAssignment_2_2.eContents().get(0);
		
		/// *
		//
		// * A Local Variable definition needs a name, followed by an equalsign and either an Instruction, an Alias or a Type  
		//
		// * / LocalVar:
		//
		//	name=Type "=" ("type" type=Type | instr=Instruction | alias=Alias);
		public ParserRule getRule() { return rule; }

		//name=Type "=" ("type" type=Type | instr=Instruction | alias=Alias)
		public Group getGroup() { return cGroup; }

		//name=Type
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//Type
		public RuleCall getNameTypeParserRuleCall_0_0() { return cNameTypeParserRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"type" type=Type | instr=Instruction | alias=Alias
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"type" type=Type
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"type"
		public Keyword getTypeKeyword_2_0_0() { return cTypeKeyword_2_0_0; }

		//type=Type
		public Assignment getTypeAssignment_2_0_1() { return cTypeAssignment_2_0_1; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_2_0_1_0() { return cTypeTypeParserRuleCall_2_0_1_0; }

		//instr=Instruction
		public Assignment getInstrAssignment_2_1() { return cInstrAssignment_2_1; }

		//Instruction
		public RuleCall getInstrInstructionParserRuleCall_2_1_0() { return cInstrInstructionParserRuleCall_2_1_0; }

		//alias=Alias
		public Assignment getAliasAssignment_2_2() { return cAliasAssignment_2_2; }

		//Alias
		public RuleCall getAliasAliasParserRuleCall_2_2_0() { return cAliasAliasParserRuleCall_2_2_0; }
	}

	public class AliasElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Alias");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAliasKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cALIAS_LINKAGEParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cVISIBILITYParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeAndValueParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Assignment cAliaseeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAliaseeTypeParserRuleCall_4_0 = (RuleCall)cAliaseeAssignment_4.eContents().get(0);
		
		/// *
		//
		// * Aliases act as "second name" for the aliasee value (which can be either function, 
		//
		// * global variable, another alias or bitcast of global value). 
		//
		// * Aliases may have an optional linkage type, and an optional visibility style
		//
		// * / Alias:
		//
		//	"alias" ALIAS_LINKAGE? VISIBILITY? type=TypeAndValue aliasee=Type;
		public ParserRule getRule() { return rule; }

		//"alias" ALIAS_LINKAGE? VISIBILITY? type=TypeAndValue aliasee=Type
		public Group getGroup() { return cGroup; }

		//"alias"
		public Keyword getAliasKeyword_0() { return cAliasKeyword_0; }

		//ALIAS_LINKAGE?
		public RuleCall getALIAS_LINKAGEParserRuleCall_1() { return cALIAS_LINKAGEParserRuleCall_1; }

		//VISIBILITY?
		public RuleCall getVISIBILITYParserRuleCall_2() { return cVISIBILITYParserRuleCall_2; }

		//type=TypeAndValue
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//TypeAndValue
		public RuleCall getTypeTypeAndValueParserRuleCall_3_0() { return cTypeTypeAndValueParserRuleCall_3_0; }

		//aliasee=Type
		public Assignment getAliaseeAssignment_4() { return cAliaseeAssignment_4; }

		//Type
		public RuleCall getAliaseeTypeParserRuleCall_4_0() { return cAliaseeTypeParserRuleCall_4_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cStructTypeParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cVAR_TYPETerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cB_TYPEParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		/// *
		//
		// * Types..
		//
		// * A Type is a type.
		//
		// * There are different types. Primitive Types, Struct Types, or own VaraiableTypes.
		//
		// * This rule is used to summarize them
		//
		// * / Type:
		//
		//	(StructType | VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES?;
		public ParserRule getRule() { return rule; }

		//(StructType | VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES?
		public Group getGroup() { return cGroup; }

		//StructType | VAR_TYPE | B_TYPE
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//StructType
		public RuleCall getStructTypeParserRuleCall_0_0() { return cStructTypeParserRuleCall_0_0; }

		//VAR_TYPE
		public RuleCall getVAR_TYPETerminalRuleCall_0_1() { return cVAR_TYPETerminalRuleCall_0_1; }

		//B_TYPE
		public RuleCall getB_TYPEParserRuleCall_0_2() { return cB_TYPEParserRuleCall_0_2; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_1() { return cRETURN_ATTRIBUTESParserRuleCall_1; }
	}

	public class TypeAndValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeAndValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cTypeAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Alternatives cTypeAlternatives_0_0_0 = (Alternatives)cTypeAssignment_0_0.eContents().get(0);
		private final RuleCall cTypeVAR_TYPETerminalRuleCall_0_0_0_0 = (RuleCall)cTypeAlternatives_0_0_0.eContents().get(0);
		private final RuleCall cTypeB_TYPEParserRuleCall_0_0_0_1 = (RuleCall)cTypeAlternatives_0_0_0.eContents().get(1);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Assignment cValueAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cValueTypeParserRuleCall_0_2_0 = (RuleCall)cValueAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cAggregateAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cAggregateAggregateParserRuleCall_1_0_0 = (RuleCall)cAggregateAssignment_1_0.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueTypeParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		/// *
		//
		// * This rule is used to bind a Type to a value.
		//
		// * It is used for example on parameterlists, on instructions etc.
		//
		// * / TypeAndValue:
		//
		//	type=(VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? value=Type | aggregate=Aggregate value=Type;
		public ParserRule getRule() { return rule; }

		//type=(VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? value=Type | aggregate=Aggregate value=Type
		public Alternatives getAlternatives() { return cAlternatives; }

		//type=(VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? value=Type
		public Group getGroup_0() { return cGroup_0; }

		//type=(VAR_TYPE | B_TYPE)
		public Assignment getTypeAssignment_0_0() { return cTypeAssignment_0_0; }

		//VAR_TYPE | B_TYPE
		public Alternatives getTypeAlternatives_0_0_0() { return cTypeAlternatives_0_0_0; }

		//VAR_TYPE
		public RuleCall getTypeVAR_TYPETerminalRuleCall_0_0_0_0() { return cTypeVAR_TYPETerminalRuleCall_0_0_0_0; }

		//B_TYPE
		public RuleCall getTypeB_TYPEParserRuleCall_0_0_0_1() { return cTypeB_TYPEParserRuleCall_0_0_0_1; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_0_1() { return cRETURN_ATTRIBUTESParserRuleCall_0_1; }

		//value=Type
		public Assignment getValueAssignment_0_2() { return cValueAssignment_0_2; }

		//Type
		public RuleCall getValueTypeParserRuleCall_0_2_0() { return cValueTypeParserRuleCall_0_2_0; }

		//aggregate=Aggregate value=Type
		public Group getGroup_1() { return cGroup_1; }

		//aggregate=Aggregate
		public Assignment getAggregateAssignment_1_0() { return cAggregateAssignment_1_0; }

		//Aggregate
		public RuleCall getAggregateAggregateParserRuleCall_1_0_0() { return cAggregateAggregateParserRuleCall_1_0_0; }

		//value=Type
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//Type
		public RuleCall getValueTypeParserRuleCall_1_1_0() { return cValueTypeParserRuleCall_1_1_0; }
	}

	public class StructTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StructType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Alternatives cAlternatives_0_1_0 = (Alternatives)cGroup_0_1.eContents().get(0);
		private final RuleCall cVAR_TYPETerminalRuleCall_0_1_0_0 = (RuleCall)cAlternatives_0_1_0.eContents().get(0);
		private final RuleCall cB_TYPEParserRuleCall_0_1_0_1 = (RuleCall)cAlternatives_0_1_0.eContents().get(1);
		private final Group cGroup_0_1_1 = (Group)cGroup_0_1.eContents().get(1);
		private final Keyword cCommaKeyword_0_1_1_0 = (Keyword)cGroup_0_1_1.eContents().get(0);
		private final Alternatives cAlternatives_0_1_1_1 = (Alternatives)cGroup_0_1_1.eContents().get(1);
		private final RuleCall cVAR_TYPETerminalRuleCall_0_1_1_1_0 = (RuleCall)cAlternatives_0_1_1_1.eContents().get(0);
		private final RuleCall cB_TYPEParserRuleCall_0_1_1_1_1 = (RuleCall)cAlternatives_0_1_1_1.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Alternatives cAlternatives_1_2_0 = (Alternatives)cGroup_1_2.eContents().get(0);
		private final RuleCall cVAR_TYPETerminalRuleCall_1_2_0_0 = (RuleCall)cAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cB_TYPEParserRuleCall_1_2_0_1 = (RuleCall)cAlternatives_1_2_0.eContents().get(1);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Alternatives cAlternatives_1_2_1_1 = (Alternatives)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cVAR_TYPETerminalRuleCall_1_2_1_1_0 = (RuleCall)cAlternatives_1_2_1_1.eContents().get(0);
		private final RuleCall cB_TYPEParserRuleCall_1_2_1_1_1 = (RuleCall)cAlternatives_1_2_1_1.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Keyword cGreaterThanSignKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		
		/// *
		//
		// * This rule specified Stuctures
		//
		// * / StructType:
		//
		//	"{" ((VAR_TYPE | B_TYPE) ("," (VAR_TYPE | B_TYPE))*)? "}" | "<" "{" ((VAR_TYPE | B_TYPE) ("," (VAR_TYPE | B_TYPE))*)?
		//
		//	"}" ">";
		public ParserRule getRule() { return rule; }

		//"{" ((VAR_TYPE | B_TYPE) ("," (VAR_TYPE | B_TYPE))*)? "}" | "<" "{" ((VAR_TYPE | B_TYPE) ("," (VAR_TYPE | B_TYPE))*)?
		//
		//"}" ">"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"{" ((VAR_TYPE | B_TYPE) ("," (VAR_TYPE | B_TYPE))*)? "}"
		public Group getGroup_0() { return cGroup_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0_0() { return cLeftCurlyBracketKeyword_0_0; }

		//((VAR_TYPE | B_TYPE) ("," (VAR_TYPE | B_TYPE))*)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//VAR_TYPE | B_TYPE
		public Alternatives getAlternatives_0_1_0() { return cAlternatives_0_1_0; }

		//VAR_TYPE
		public RuleCall getVAR_TYPETerminalRuleCall_0_1_0_0() { return cVAR_TYPETerminalRuleCall_0_1_0_0; }

		//B_TYPE
		public RuleCall getB_TYPEParserRuleCall_0_1_0_1() { return cB_TYPEParserRuleCall_0_1_0_1; }

		//("," (VAR_TYPE | B_TYPE))*
		public Group getGroup_0_1_1() { return cGroup_0_1_1; }

		//","
		public Keyword getCommaKeyword_0_1_1_0() { return cCommaKeyword_0_1_1_0; }

		//VAR_TYPE | B_TYPE
		public Alternatives getAlternatives_0_1_1_1() { return cAlternatives_0_1_1_1; }

		//VAR_TYPE
		public RuleCall getVAR_TYPETerminalRuleCall_0_1_1_1_0() { return cVAR_TYPETerminalRuleCall_0_1_1_1_0; }

		//B_TYPE
		public RuleCall getB_TYPEParserRuleCall_0_1_1_1_1() { return cB_TYPEParserRuleCall_0_1_1_1_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_0_2() { return cRightCurlyBracketKeyword_0_2; }

		//"<" "{" ((VAR_TYPE | B_TYPE) ("," (VAR_TYPE | B_TYPE))*)? "}" ">"
		public Group getGroup_1() { return cGroup_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0() { return cLessThanSignKeyword_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }

		//((VAR_TYPE | B_TYPE) ("," (VAR_TYPE | B_TYPE))*)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//VAR_TYPE | B_TYPE
		public Alternatives getAlternatives_1_2_0() { return cAlternatives_1_2_0; }

		//VAR_TYPE
		public RuleCall getVAR_TYPETerminalRuleCall_1_2_0_0() { return cVAR_TYPETerminalRuleCall_1_2_0_0; }

		//B_TYPE
		public RuleCall getB_TYPEParserRuleCall_1_2_0_1() { return cB_TYPEParserRuleCall_1_2_0_1; }

		//("," (VAR_TYPE | B_TYPE))*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//","
		public Keyword getCommaKeyword_1_2_1_0() { return cCommaKeyword_1_2_1_0; }

		//VAR_TYPE | B_TYPE
		public Alternatives getAlternatives_1_2_1_1() { return cAlternatives_1_2_1_1; }

		//VAR_TYPE
		public RuleCall getVAR_TYPETerminalRuleCall_1_2_1_1_0() { return cVAR_TYPETerminalRuleCall_1_2_1_1_0; }

		//B_TYPE
		public RuleCall getB_TYPEParserRuleCall_1_2_1_1_1() { return cB_TYPEParserRuleCall_1_2_1_1_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_3() { return cRightCurlyBracketKeyword_1_3; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_4() { return cGreaterThanSignKeyword_1_4; }
	}

	public class B_TYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "B_TYPE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTEGERTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cF_POINTParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBASIC_TYPEParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		/// *
		//
		// * To summerize all BASIC_TYPEs inside one Rule.
		//
		// * / B_TYPE:
		//
		//	INTEGER | F_POINT | BASIC_TYPE | INT;
		public ParserRule getRule() { return rule; }

		//INTEGER | F_POINT | BASIC_TYPE | INT
		public Alternatives getAlternatives() { return cAlternatives; }

		//INTEGER
		public RuleCall getINTEGERTerminalRuleCall_0() { return cINTEGERTerminalRuleCall_0; }

		//F_POINT
		public RuleCall getF_POINTParserRuleCall_1() { return cF_POINTParserRuleCall_1; }

		//BASIC_TYPE
		public RuleCall getBASIC_TYPEParserRuleCall_2() { return cBASIC_TYPEParserRuleCall_2; }

		//INT
		public RuleCall getINTTerminalRuleCall_3() { return cINTTerminalRuleCall_3; }
	}

	public class BASIC_TYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BASIC_TYPE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cVoidKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLabelKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cUndefKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cTrueKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cFalseKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		/// *
		//
		// * To distinguish the types here only Basic Types
		//
		// * / BASIC_TYPE:
		//
		//	"void" | "null" | "label" | "undef" | "true" | "false";
		public ParserRule getRule() { return rule; }

		//"void" | "null" | "label" | "undef" | "true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"void"
		public Keyword getVoidKeyword_0() { return cVoidKeyword_0; }

		//"null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }

		//"label"
		public Keyword getLabelKeyword_2() { return cLabelKeyword_2; }

		//"undef"
		public Keyword getUndefKeyword_3() { return cUndefKeyword_3; }

		//"true"
		public Keyword getTrueKeyword_4() { return cTrueKeyword_4; }

		//"false"
		public Keyword getFalseKeyword_5() { return cFalseKeyword_5; }
	}

	public class F_POINTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "F_POINT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHalfKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFloatKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDoubleKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cX86_fp80Keyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cFp128Keyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cPpc_fp128Keyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		/// *
		//
		// * To distinguish the types here only Floating Types
		//
		// * / F_POINT:
		//
		//	"half" | "float" | "double" | "x86_fp80" | "fp128" | "ppc_fp128";
		public ParserRule getRule() { return rule; }

		//"half" | "float" | "double" | "x86_fp80" | "fp128" | "ppc_fp128"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"half"
		public Keyword getHalfKeyword_0() { return cHalfKeyword_0; }

		//"float"
		public Keyword getFloatKeyword_1() { return cFloatKeyword_1; }

		//"double"
		public Keyword getDoubleKeyword_2() { return cDoubleKeyword_2; }

		//"x86_fp80"
		public Keyword getX86_fp80Keyword_3() { return cX86_fp80Keyword_3; }

		//"fp128"
		public Keyword getFp128Keyword_4() { return cFp128Keyword_4; }

		//"ppc_fp128"
		public Keyword getPpc_fp128Keyword_5() { return cPpc_fp128Keyword_5; }
	}

	public class GetElementPtrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GetElementPtr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetelementptrKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cInboundsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPointerAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPointerTypeAndValueParserRuleCall_2_0 = (RuleCall)cPointerAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParamsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParamsTypeAndValueParserRuleCall_3_1_0 = (RuleCall)cParamsAssignment_3_1.eContents().get(0);
		
		/// *
		//
		// * The 'getelementptr' instruction is used to get the address of a subelement of an aggregate data structure. 
		//
		// * It performs address calculation only and does not access memory.
		//
		// * / GetElementPtr:
		//
		//	"getelementptr" "inbounds"? pointer+=TypeAndValue ("," params+=TypeAndValue)*;
		public ParserRule getRule() { return rule; }

		//"getelementptr" "inbounds"? pointer+=TypeAndValue ("," params+=TypeAndValue)*
		public Group getGroup() { return cGroup; }

		//"getelementptr"
		public Keyword getGetelementptrKeyword_0() { return cGetelementptrKeyword_0; }

		//"inbounds"?
		public Keyword getInboundsKeyword_1() { return cInboundsKeyword_1; }

		//pointer+=TypeAndValue
		public Assignment getPointerAssignment_2() { return cPointerAssignment_2; }

		//TypeAndValue
		public RuleCall getPointerTypeAndValueParserRuleCall_2_0() { return cPointerTypeAndValueParserRuleCall_2_0; }

		//("," params+=TypeAndValue)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//params+=TypeAndValue
		public Assignment getParamsAssignment_3_1() { return cParamsAssignment_3_1; }

		//TypeAndValue
		public RuleCall getParamsTypeAndValueParserRuleCall_3_1_0() { return cParamsTypeAndValueParserRuleCall_3_1_0; }
	}

	public class ExtractValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExtractValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExtractvalueKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAggregateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAggregateAggregateParserRuleCall_1_0 = (RuleCall)cAggregateAssignment_1.eContents().get(0);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cIndexAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cIndexINTTerminalRuleCall_3_1_0 = (RuleCall)cIndexAssignment_3_1.eContents().get(0);
		
		/// *
		//
		// * The 'extractvalue' instruction extracts the value of a member field from an aggregate value.
		//
		// * / ExtractValue:
		//
		//	"extractvalue" aggregate=Aggregate type=Type ("," index+=INT)+;
		public ParserRule getRule() { return rule; }

		//"extractvalue" aggregate=Aggregate type=Type ("," index+=INT)+
		public Group getGroup() { return cGroup; }

		//"extractvalue"
		public Keyword getExtractvalueKeyword_0() { return cExtractvalueKeyword_0; }

		//aggregate=Aggregate
		public Assignment getAggregateAssignment_1() { return cAggregateAssignment_1; }

		//Aggregate
		public RuleCall getAggregateAggregateParserRuleCall_1_0() { return cAggregateAggregateParserRuleCall_1_0; }

		//type=Type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }

		//("," index+=INT)+
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//index+=INT
		public Assignment getIndexAssignment_3_1() { return cIndexAssignment_3_1; }

		//INT
		public RuleCall getIndexINTTerminalRuleCall_3_1_0() { return cIndexINTTerminalRuleCall_3_1_0; }
	}

	public class InsertValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InsertValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInsertvalueKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAggregateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAggregateAggregateParserRuleCall_1_0 = (RuleCall)cAggregateAssignment_1.eContents().get(0);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValueTypeAndValueParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cIndexAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cIndexINTTerminalRuleCall_5_1_0 = (RuleCall)cIndexAssignment_5_1.eContents().get(0);
		
		/// *
		//
		// * The 'insertvalue' instruction inserts a value into a member field in an aggregate value.
		//
		// * / InsertValue:
		//
		//	"insertvalue" aggregate=Aggregate type=Type "," value=TypeAndValue ("," index+=INT)+;
		public ParserRule getRule() { return rule; }

		//"insertvalue" aggregate=Aggregate type=Type "," value=TypeAndValue ("," index+=INT)+
		public Group getGroup() { return cGroup; }

		//"insertvalue"
		public Keyword getInsertvalueKeyword_0() { return cInsertvalueKeyword_0; }

		//aggregate=Aggregate
		public Assignment getAggregateAssignment_1() { return cAggregateAssignment_1; }

		//Aggregate
		public RuleCall getAggregateAggregateParserRuleCall_1_0() { return cAggregateAggregateParserRuleCall_1_0; }

		//type=Type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//value=TypeAndValue
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }

		//TypeAndValue
		public RuleCall getValueTypeAndValueParserRuleCall_4_0() { return cValueTypeAndValueParserRuleCall_4_0; }

		//("," index+=INT)+
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//index+=INT
		public Assignment getIndexAssignment_5_1() { return cIndexAssignment_5_1; }

		//INT
		public RuleCall getIndexINTTerminalRuleCall_5_1_0() { return cIndexINTTerminalRuleCall_5_1_0; }
	}

	public class FenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Fence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFenceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cSinglethreadKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOrderingAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOrderingATOMIC_ORDERINGParserRuleCall_2_0 = (RuleCall)cOrderingAssignment_2.eContents().get(0);
		
		/// *
		//
		// * The 'fence' instruction is used to introduce happens-before edges between operations.
		//
		// * / Fence:
		//
		//	"fence" "singlethread"? ordering=ATOMIC_ORDERING;
		public ParserRule getRule() { return rule; }

		//"fence" "singlethread"? ordering=ATOMIC_ORDERING
		public Group getGroup() { return cGroup; }

		//"fence"
		public Keyword getFenceKeyword_0() { return cFenceKeyword_0; }

		//"singlethread"?
		public Keyword getSinglethreadKeyword_1() { return cSinglethreadKeyword_1; }

		//ordering=ATOMIC_ORDERING
		public Assignment getOrderingAssignment_2() { return cOrderingAssignment_2; }

		//ATOMIC_ORDERING
		public RuleCall getOrderingATOMIC_ORDERINGParserRuleCall_2_0() { return cOrderingATOMIC_ORDERINGParserRuleCall_2_0; }
	}

	public class ATOMIC_ORDERINGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ATOMIC_ORDERING");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cUnorderedKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMonotonicKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAquireKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cReleaseKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cAcq_relKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cSeq_cstKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		/// *
		//
		// * This is only a summarize of the possible atomic orderings
		//
		// * / ATOMIC_ORDERING:
		//
		//	"unordered" | "monotonic" | "aquire" | "release" | "acq_rel" | "seq_cst";
		public ParserRule getRule() { return rule; }

		//"unordered" | "monotonic" | "aquire" | "release" | "acq_rel" | "seq_cst"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"unordered"
		public Keyword getUnorderedKeyword_0() { return cUnorderedKeyword_0; }

		//"monotonic"
		public Keyword getMonotonicKeyword_1() { return cMonotonicKeyword_1; }

		//"aquire"
		public Keyword getAquireKeyword_2() { return cAquireKeyword_2; }

		//"release"
		public Keyword getReleaseKeyword_3() { return cReleaseKeyword_3; }

		//"acq_rel"
		public Keyword getAcq_relKeyword_4() { return cAcq_relKeyword_4; }

		//"seq_cst"
		public Keyword getSeq_cstKeyword_5() { return cSeq_cstKeyword_5; }
	}

	public class CmpXchgElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CmpXchg");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCmpxchgKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cVolatileKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAdressAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAdressTypeAndValueParserRuleCall_2_0 = (RuleCall)cAdressAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cCompare_valAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCompare_valTypeAndValueParserRuleCall_4_0 = (RuleCall)cCompare_valAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cNew_valAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cNew_valTypeAndValueParserRuleCall_6_0 = (RuleCall)cNew_valAssignment_6.eContents().get(0);
		private final Keyword cSinglethreadKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cOrderingAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cOrderingATOMIC_ORDERINGParserRuleCall_8_0 = (RuleCall)cOrderingAssignment_8.eContents().get(0);
		
		/// *
		//
		// * The 'cmpxchg' instruction is used to atomically modify memory. It loads a value in memory and compares it to 
		//
		// * a given value. If they are equal, it stores a new value into the memory.
		//
		// * / CmpXchg:
		//
		//	"cmpxchg" "volatile"? adress=TypeAndValue "," compare_val=TypeAndValue "," new_val=TypeAndValue "singlethread"?
		//
		//	ordering=ATOMIC_ORDERING;
		public ParserRule getRule() { return rule; }

		//"cmpxchg" "volatile"? adress=TypeAndValue "," compare_val=TypeAndValue "," new_val=TypeAndValue "singlethread"?
		//
		//ordering=ATOMIC_ORDERING
		public Group getGroup() { return cGroup; }

		//"cmpxchg"
		public Keyword getCmpxchgKeyword_0() { return cCmpxchgKeyword_0; }

		//"volatile"?
		public Keyword getVolatileKeyword_1() { return cVolatileKeyword_1; }

		//adress=TypeAndValue
		public Assignment getAdressAssignment_2() { return cAdressAssignment_2; }

		//TypeAndValue
		public RuleCall getAdressTypeAndValueParserRuleCall_2_0() { return cAdressTypeAndValueParserRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//compare_val=TypeAndValue
		public Assignment getCompare_valAssignment_4() { return cCompare_valAssignment_4; }

		//TypeAndValue
		public RuleCall getCompare_valTypeAndValueParserRuleCall_4_0() { return cCompare_valTypeAndValueParserRuleCall_4_0; }

		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }

		//new_val=TypeAndValue
		public Assignment getNew_valAssignment_6() { return cNew_valAssignment_6; }

		//TypeAndValue
		public RuleCall getNew_valTypeAndValueParserRuleCall_6_0() { return cNew_valTypeAndValueParserRuleCall_6_0; }

		//"singlethread"?
		public Keyword getSinglethreadKeyword_7() { return cSinglethreadKeyword_7; }

		//ordering=ATOMIC_ORDERING
		public Assignment getOrderingAssignment_8() { return cOrderingAssignment_8; }

		//ATOMIC_ORDERING
		public RuleCall getOrderingATOMIC_ORDERINGParserRuleCall_8_0() { return cOrderingATOMIC_ORDERINGParserRuleCall_8_0; }
	}

	public class AtomicRMWElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomicRMW");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAtomicrmwKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cVolatileKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cBIN_OPParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cAdressAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAdressTypeAndValueParserRuleCall_3_0 = (RuleCall)cAdressAssignment_3.eContents().get(0);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValueAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValueTypeAndValueParserRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		private final Keyword cSinglethreadKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cOrderingAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cOrderingATOMIC_ORDERINGParserRuleCall_7_0 = (RuleCall)cOrderingAssignment_7.eContents().get(0);
		
		/// *
		//
		// * The 'atomicrmw' instruction is used to atomically modify memory.
		//
		// * / AtomicRMW:
		//
		//	"atomicrmw" "volatile"? BIN_OP adress=TypeAndValue "," value=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING;
		public ParserRule getRule() { return rule; }

		//"atomicrmw" "volatile"? BIN_OP adress=TypeAndValue "," value=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING
		public Group getGroup() { return cGroup; }

		//"atomicrmw"
		public Keyword getAtomicrmwKeyword_0() { return cAtomicrmwKeyword_0; }

		//"volatile"?
		public Keyword getVolatileKeyword_1() { return cVolatileKeyword_1; }

		//BIN_OP
		public RuleCall getBIN_OPParserRuleCall_2() { return cBIN_OPParserRuleCall_2; }

		//adress=TypeAndValue
		public Assignment getAdressAssignment_3() { return cAdressAssignment_3; }

		//TypeAndValue
		public RuleCall getAdressTypeAndValueParserRuleCall_3_0() { return cAdressTypeAndValueParserRuleCall_3_0; }

		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }

		//value=TypeAndValue
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }

		//TypeAndValue
		public RuleCall getValueTypeAndValueParserRuleCall_5_0() { return cValueTypeAndValueParserRuleCall_5_0; }

		//"singlethread"?
		public Keyword getSinglethreadKeyword_6() { return cSinglethreadKeyword_6; }

		//ordering=ATOMIC_ORDERING
		public Assignment getOrderingAssignment_7() { return cOrderingAssignment_7; }

		//ATOMIC_ORDERING
		public RuleCall getOrderingATOMIC_ORDERINGParserRuleCall_7_0() { return cOrderingATOMIC_ORDERINGParserRuleCall_7_0; }
	}

	public class BIN_OPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BIN_OP");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cXchgKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAddKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSubKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cAndKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cNandKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cOrKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cXorKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cMaxKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cMinKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cUmaxKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cUminKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		
		/// *
		//
		// * This is only to summarize the different Binary Operations
		//
		// * / BIN_OP:
		//
		//	"xchg" | "add" | "sub" | "and" | "nand" | "or" | "xor" | "max" | "min" | "umax" | "umin";
		public ParserRule getRule() { return rule; }

		//"xchg" | "add" | "sub" | "and" | "nand" | "or" | "xor" | "max" | "min" | "umax" | "umin"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"xchg"
		public Keyword getXchgKeyword_0() { return cXchgKeyword_0; }

		//"add"
		public Keyword getAddKeyword_1() { return cAddKeyword_1; }

		//"sub"
		public Keyword getSubKeyword_2() { return cSubKeyword_2; }

		//"and"
		public Keyword getAndKeyword_3() { return cAndKeyword_3; }

		//"nand"
		public Keyword getNandKeyword_4() { return cNandKeyword_4; }

		//"or"
		public Keyword getOrKeyword_5() { return cOrKeyword_5; }

		//"xor"
		public Keyword getXorKeyword_6() { return cXorKeyword_6; }

		//"max"
		public Keyword getMaxKeyword_7() { return cMaxKeyword_7; }

		//"min"
		public Keyword getMinKeyword_8() { return cMinKeyword_8; }

		//"umax"
		public Keyword getUmaxKeyword_9() { return cUmaxKeyword_9; }

		//"umin"
		public Keyword getUminKeyword_10() { return cUminKeyword_10; }
	}

	public class LoadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Load");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLoadKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cVolatileKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cAdressAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cAdressTypeAndValueParserRuleCall_0_2_0 = (RuleCall)cAdressAssignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Alternatives cAlternatives_0_3_1 = (Alternatives)cGroup_0_3.eContents().get(1);
		private final RuleCall cALIGNMENTParserRuleCall_0_3_1_0 = (RuleCall)cAlternatives_0_3_1.eContents().get(0);
		private final RuleCall cMetadataValueParserRuleCall_0_3_1_1 = (RuleCall)cAlternatives_0_3_1.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLoadKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cAtomicKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cVolatileKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cAdressAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cAdressTypeAndValueParserRuleCall_1_3_0 = (RuleCall)cAdressAssignment_1_3.eContents().get(0);
		private final Keyword cSinglethreadKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cOrderingAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cOrderingATOMIC_ORDERINGParserRuleCall_1_5_0 = (RuleCall)cOrderingAssignment_1_5.eContents().get(0);
		private final Group cGroup_1_6 = (Group)cGroup_1.eContents().get(6);
		private final Keyword cCommaKeyword_1_6_0 = (Keyword)cGroup_1_6.eContents().get(0);
		private final Keyword cAlignKeyword_1_6_1 = (Keyword)cGroup_1_6.eContents().get(1);
		private final Assignment cIndexAssignment_1_6_2 = (Assignment)cGroup_1_6.eContents().get(2);
		private final RuleCall cIndexINTTerminalRuleCall_1_6_2_0 = (RuleCall)cIndexAssignment_1_6_2.eContents().get(0);
		
		/// *
		//
		// * The 'load' instruction is used to read from memory.
		//
		// * / Load:
		//
		//	"load" "volatile"? adress=TypeAndValue ("," (ALIGNMENT | MetadataValue+))* | "load" "atomic" "volatile"?
		//
		//	adress=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING ("," "align" index=INT)?;
		public ParserRule getRule() { return rule; }

		//"load" "volatile"? adress=TypeAndValue ("," (ALIGNMENT | MetadataValue+))* | "load" "atomic" "volatile"?
		//
		//adress=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING ("," "align" index=INT)?
		public Alternatives getAlternatives() { return cAlternatives; }

		//"load" "volatile"? adress=TypeAndValue ("," (ALIGNMENT | MetadataValue+))*
		public Group getGroup_0() { return cGroup_0; }

		//"load"
		public Keyword getLoadKeyword_0_0() { return cLoadKeyword_0_0; }

		//"volatile"?
		public Keyword getVolatileKeyword_0_1() { return cVolatileKeyword_0_1; }

		//adress=TypeAndValue
		public Assignment getAdressAssignment_0_2() { return cAdressAssignment_0_2; }

		//TypeAndValue
		public RuleCall getAdressTypeAndValueParserRuleCall_0_2_0() { return cAdressTypeAndValueParserRuleCall_0_2_0; }

		//("," (ALIGNMENT | MetadataValue+))*
		public Group getGroup_0_3() { return cGroup_0_3; }

		//","
		public Keyword getCommaKeyword_0_3_0() { return cCommaKeyword_0_3_0; }

		//ALIGNMENT | MetadataValue+
		public Alternatives getAlternatives_0_3_1() { return cAlternatives_0_3_1; }

		//ALIGNMENT
		public RuleCall getALIGNMENTParserRuleCall_0_3_1_0() { return cALIGNMENTParserRuleCall_0_3_1_0; }

		//MetadataValue+
		public RuleCall getMetadataValueParserRuleCall_0_3_1_1() { return cMetadataValueParserRuleCall_0_3_1_1; }

		//"load" "atomic" "volatile"? adress=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING ("," "align" index=INT)?
		public Group getGroup_1() { return cGroup_1; }

		//"load"
		public Keyword getLoadKeyword_1_0() { return cLoadKeyword_1_0; }

		//"atomic"
		public Keyword getAtomicKeyword_1_1() { return cAtomicKeyword_1_1; }

		//"volatile"?
		public Keyword getVolatileKeyword_1_2() { return cVolatileKeyword_1_2; }

		//adress=TypeAndValue
		public Assignment getAdressAssignment_1_3() { return cAdressAssignment_1_3; }

		//TypeAndValue
		public RuleCall getAdressTypeAndValueParserRuleCall_1_3_0() { return cAdressTypeAndValueParserRuleCall_1_3_0; }

		//"singlethread"?
		public Keyword getSinglethreadKeyword_1_4() { return cSinglethreadKeyword_1_4; }

		//ordering=ATOMIC_ORDERING
		public Assignment getOrderingAssignment_1_5() { return cOrderingAssignment_1_5; }

		//ATOMIC_ORDERING
		public RuleCall getOrderingATOMIC_ORDERINGParserRuleCall_1_5_0() { return cOrderingATOMIC_ORDERINGParserRuleCall_1_5_0; }

		//("," "align" index=INT)?
		public Group getGroup_1_6() { return cGroup_1_6; }

		//","
		public Keyword getCommaKeyword_1_6_0() { return cCommaKeyword_1_6_0; }

		//"align"
		public Keyword getAlignKeyword_1_6_1() { return cAlignKeyword_1_6_1; }

		//index=INT
		public Assignment getIndexAssignment_1_6_2() { return cIndexAssignment_1_6_2; }

		//INT
		public RuleCall getIndexINTTerminalRuleCall_1_6_2_0() { return cIndexINTTerminalRuleCall_1_6_2_0; }
	}

	public class StoreElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Store");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cStoreKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cVolatileKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cValueAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cValueTypeAndValueParserRuleCall_0_2_0 = (RuleCall)cValueAssignment_0_2.eContents().get(0);
		private final Keyword cCommaKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cAdressAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cAdressTypeAndValueParserRuleCall_0_4_0 = (RuleCall)cAdressAssignment_0_4.eContents().get(0);
		private final Group cGroup_0_5 = (Group)cGroup_0.eContents().get(5);
		private final Keyword cCommaKeyword_0_5_0 = (Keyword)cGroup_0_5.eContents().get(0);
		private final Alternatives cAlternatives_0_5_1 = (Alternatives)cGroup_0_5.eContents().get(1);
		private final RuleCall cALIGNMENTParserRuleCall_0_5_1_0 = (RuleCall)cAlternatives_0_5_1.eContents().get(0);
		private final RuleCall cMetadataValueParserRuleCall_0_5_1_1 = (RuleCall)cAlternatives_0_5_1.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cStoreKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cAtomicKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cVolatileKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cValueAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cValueTypeAndValueParserRuleCall_1_3_0 = (RuleCall)cValueAssignment_1_3.eContents().get(0);
		private final Keyword cCommaKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cAdressAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cAdressTypeAndValueParserRuleCall_1_5_0 = (RuleCall)cAdressAssignment_1_5.eContents().get(0);
		private final Keyword cSinglethreadKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		private final Assignment cOrderingAssignment_1_7 = (Assignment)cGroup_1.eContents().get(7);
		private final RuleCall cOrderingATOMIC_ORDERINGParserRuleCall_1_7_0 = (RuleCall)cOrderingAssignment_1_7.eContents().get(0);
		private final Group cGroup_1_8 = (Group)cGroup_1.eContents().get(8);
		private final Keyword cCommaKeyword_1_8_0 = (Keyword)cGroup_1_8.eContents().get(0);
		private final Keyword cAlignKeyword_1_8_1 = (Keyword)cGroup_1_8.eContents().get(1);
		private final Assignment cIndexAssignment_1_8_2 = (Assignment)cGroup_1_8.eContents().get(2);
		private final RuleCall cIndexINTTerminalRuleCall_1_8_2_0 = (RuleCall)cIndexAssignment_1_8_2.eContents().get(0);
		
		/// *
		//
		// * The 'store' instruction is used to write to memory.
		//
		// * / Store:
		//
		//	"store" "volatile"? value=TypeAndValue "," adress=TypeAndValue ("," (ALIGNMENT | MetadataValue+))* | "store" "atomic"
		//
		//	"volatile"? value=TypeAndValue "," adress=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING ("," "align"
		//
		//	index=INT)?;
		public ParserRule getRule() { return rule; }

		//"store" "volatile"? value=TypeAndValue "," adress=TypeAndValue ("," (ALIGNMENT | MetadataValue+))* | "store" "atomic"
		//
		//"volatile"? value=TypeAndValue "," adress=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING ("," "align"
		//
		//index=INT)?
		public Alternatives getAlternatives() { return cAlternatives; }

		//"store" "volatile"? value=TypeAndValue "," adress=TypeAndValue ("," (ALIGNMENT | MetadataValue+))*
		public Group getGroup_0() { return cGroup_0; }

		//"store"
		public Keyword getStoreKeyword_0_0() { return cStoreKeyword_0_0; }

		//"volatile"?
		public Keyword getVolatileKeyword_0_1() { return cVolatileKeyword_0_1; }

		//value=TypeAndValue
		public Assignment getValueAssignment_0_2() { return cValueAssignment_0_2; }

		//TypeAndValue
		public RuleCall getValueTypeAndValueParserRuleCall_0_2_0() { return cValueTypeAndValueParserRuleCall_0_2_0; }

		//","
		public Keyword getCommaKeyword_0_3() { return cCommaKeyword_0_3; }

		//adress=TypeAndValue
		public Assignment getAdressAssignment_0_4() { return cAdressAssignment_0_4; }

		//TypeAndValue
		public RuleCall getAdressTypeAndValueParserRuleCall_0_4_0() { return cAdressTypeAndValueParserRuleCall_0_4_0; }

		//("," (ALIGNMENT | MetadataValue+))*
		public Group getGroup_0_5() { return cGroup_0_5; }

		//","
		public Keyword getCommaKeyword_0_5_0() { return cCommaKeyword_0_5_0; }

		//ALIGNMENT | MetadataValue+
		public Alternatives getAlternatives_0_5_1() { return cAlternatives_0_5_1; }

		//ALIGNMENT
		public RuleCall getALIGNMENTParserRuleCall_0_5_1_0() { return cALIGNMENTParserRuleCall_0_5_1_0; }

		//MetadataValue+
		public RuleCall getMetadataValueParserRuleCall_0_5_1_1() { return cMetadataValueParserRuleCall_0_5_1_1; }

		//"store" "atomic" "volatile"? value=TypeAndValue "," adress=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING (","
		//
		//"align" index=INT)?
		public Group getGroup_1() { return cGroup_1; }

		//"store"
		public Keyword getStoreKeyword_1_0() { return cStoreKeyword_1_0; }

		//"atomic"
		public Keyword getAtomicKeyword_1_1() { return cAtomicKeyword_1_1; }

		//"volatile"?
		public Keyword getVolatileKeyword_1_2() { return cVolatileKeyword_1_2; }

		//value=TypeAndValue
		public Assignment getValueAssignment_1_3() { return cValueAssignment_1_3; }

		//TypeAndValue
		public RuleCall getValueTypeAndValueParserRuleCall_1_3_0() { return cValueTypeAndValueParserRuleCall_1_3_0; }

		//","
		public Keyword getCommaKeyword_1_4() { return cCommaKeyword_1_4; }

		//adress=TypeAndValue
		public Assignment getAdressAssignment_1_5() { return cAdressAssignment_1_5; }

		//TypeAndValue
		public RuleCall getAdressTypeAndValueParserRuleCall_1_5_0() { return cAdressTypeAndValueParserRuleCall_1_5_0; }

		//"singlethread"?
		public Keyword getSinglethreadKeyword_1_6() { return cSinglethreadKeyword_1_6; }

		//ordering=ATOMIC_ORDERING
		public Assignment getOrderingAssignment_1_7() { return cOrderingAssignment_1_7; }

		//ATOMIC_ORDERING
		public RuleCall getOrderingATOMIC_ORDERINGParserRuleCall_1_7_0() { return cOrderingATOMIC_ORDERINGParserRuleCall_1_7_0; }

		//("," "align" index=INT)?
		public Group getGroup_1_8() { return cGroup_1_8; }

		//","
		public Keyword getCommaKeyword_1_8_0() { return cCommaKeyword_1_8_0; }

		//"align"
		public Keyword getAlignKeyword_1_8_1() { return cAlignKeyword_1_8_1; }

		//index=INT
		public Assignment getIndexAssignment_1_8_2() { return cIndexAssignment_1_8_2; }

		//INT
		public RuleCall getIndexINTTerminalRuleCall_1_8_2_0() { return cIndexINTTerminalRuleCall_1_8_2_0; }
	}

	public class CallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Call");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTailKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cCallKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cCallingConvParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cPointerAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPointerTypeAndValueParserRuleCall_4_0 = (RuleCall)cPointerAssignment_4.eContents().get(0);
		private final Assignment cPListAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cPListParameterListParserRuleCall_5_0 = (RuleCall)cPListAssignment_5.eContents().get(0);
		private final RuleCall cFUNCTION_ATTRIBUTESParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		/// *
		//
		// * The 'call' instruction represents a simple function call.
		//
		// * / Call:
		//
		//	"tail"? "call" CallingConv? RETURN_ATTRIBUTES? pointer=TypeAndValue pList=ParameterList FUNCTION_ATTRIBUTES*;
		public ParserRule getRule() { return rule; }

		//"tail"? "call" CallingConv? RETURN_ATTRIBUTES? pointer=TypeAndValue pList=ParameterList FUNCTION_ATTRIBUTES*
		public Group getGroup() { return cGroup; }

		//"tail"?
		public Keyword getTailKeyword_0() { return cTailKeyword_0; }

		//"call"
		public Keyword getCallKeyword_1() { return cCallKeyword_1; }

		//CallingConv?
		public RuleCall getCallingConvParserRuleCall_2() { return cCallingConvParserRuleCall_2; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_3() { return cRETURN_ATTRIBUTESParserRuleCall_3; }

		//pointer=TypeAndValue
		public Assignment getPointerAssignment_4() { return cPointerAssignment_4; }

		//TypeAndValue
		public RuleCall getPointerTypeAndValueParserRuleCall_4_0() { return cPointerTypeAndValueParserRuleCall_4_0; }

		//pList=ParameterList
		public Assignment getPListAssignment_5() { return cPListAssignment_5; }

		//ParameterList
		public RuleCall getPListParameterListParserRuleCall_5_0() { return cPListParameterListParserRuleCall_5_0; }

		//FUNCTION_ATTRIBUTES*
		public RuleCall getFUNCTION_ATTRIBUTESParserRuleCall_6() { return cFUNCTION_ATTRIBUTESParserRuleCall_6; }
	}

	public class RETURN_ATTRIBUTESElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RETURN_ATTRIBUTES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cZeroextKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSignextKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cInregKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cByvalKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cSretKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cNoaliasKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cNocaptureKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cNestKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		
		/// *
		//
		// * This is to summarize the possible return attributes
		//
		// * / RETURN_ATTRIBUTES:
		//
		//	"zeroext" | "signext" | "inreg" | "byval" | "sret" | "noalias" | "nocapture" | "nest";
		public ParserRule getRule() { return rule; }

		//"zeroext" | "signext" | "inreg" | "byval" | "sret" | "noalias" | "nocapture" | "nest"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"zeroext"
		public Keyword getZeroextKeyword_0() { return cZeroextKeyword_0; }

		//"signext"
		public Keyword getSignextKeyword_1() { return cSignextKeyword_1; }

		//"inreg"
		public Keyword getInregKeyword_2() { return cInregKeyword_2; }

		//"byval"
		public Keyword getByvalKeyword_3() { return cByvalKeyword_3; }

		//"sret"
		public Keyword getSretKeyword_4() { return cSretKeyword_4; }

		//"noalias"
		public Keyword getNoaliasKeyword_5() { return cNoaliasKeyword_5; }

		//"nocapture"
		public Keyword getNocaptureKeyword_6() { return cNocaptureKeyword_6; }

		//"nest"
		public Keyword getNestKeyword_7() { return cNestKeyword_7; }
	}

	public class AllocElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Alloc");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAllocaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cNumElementsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNumElementsTypeAndValueParserRuleCall_2_1_0 = (RuleCall)cNumElementsAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cALIGNMENTParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		
		//Alloc:
		//
		//	"alloca" type=Type ("," numElements=TypeAndValue)? ("," ALIGNMENT)?;
		public ParserRule getRule() { return rule; }

		//"alloca" type=Type ("," numElements=TypeAndValue)? ("," ALIGNMENT)?
		public Group getGroup() { return cGroup; }

		//"alloca"
		public Keyword getAllocaKeyword_0() { return cAllocaKeyword_0; }

		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_1_0() { return cTypeTypeParserRuleCall_1_0; }

		//("," numElements=TypeAndValue)?
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//numElements=TypeAndValue
		public Assignment getNumElementsAssignment_2_1() { return cNumElementsAssignment_2_1; }

		//TypeAndValue
		public RuleCall getNumElementsTypeAndValueParserRuleCall_2_1_0() { return cNumElementsTypeAndValueParserRuleCall_2_1_0; }

		//("," ALIGNMENT)?
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//ALIGNMENT
		public RuleCall getALIGNMENTParserRuleCall_3_1() { return cALIGNMENTParserRuleCall_3_1; }
	}

	public class CallingConvElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CallingConv");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCccKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFastccKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cColdccKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cX86_stdcallccKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cX86_fastcallccKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cX86_thiscallccKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cArm_apcsccKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cArm_aapcsccKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cArm_aapcs_vfpccKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cMsp430_intrccKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cPtx_kernelKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cPtx_deviceKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cSpir_funcKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cSpir_kernelKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Group cGroup_14 = (Group)cAlternatives.eContents().get(14);
		private final Keyword cCcKeyword_14_0 = (Keyword)cGroup_14.eContents().get(0);
		private final Keyword cLessThanSignKeyword_14_1 = (Keyword)cGroup_14.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_14_2 = (RuleCall)cGroup_14.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_14_3 = (Keyword)cGroup_14.eContents().get(3);
		private final RuleCall cINTTerminalRuleCall_14_4 = (RuleCall)cGroup_14.eContents().get(4);
		
		/// *
		//
		// * This is to summarize the possible Calling Conventions
		//
		// * / CallingConv:
		//
		//	"ccc" | "fastcc" | "coldcc" | "x86_stdcallcc" | "x86_fastcallcc" | "x86_thiscallcc" | "arm_apcscc" | "arm_aapcscc" |
		//
		//	"arm_aapcs_vfpcc" | "msp430_intrcc" | "ptx_kernel" | "ptx_device" | "spir_func" | "spir_kernel" | "cc" "<" INT ">"
		//
		//	INT;
		public ParserRule getRule() { return rule; }

		//"ccc" | "fastcc" | "coldcc" | "x86_stdcallcc" | "x86_fastcallcc" | "x86_thiscallcc" | "arm_apcscc" | "arm_aapcscc" |
		//
		//"arm_aapcs_vfpcc" | "msp430_intrcc" | "ptx_kernel" | "ptx_device" | "spir_func" | "spir_kernel" | "cc" "<" INT ">" INT
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ccc"
		public Keyword getCccKeyword_0() { return cCccKeyword_0; }

		//"fastcc"
		public Keyword getFastccKeyword_1() { return cFastccKeyword_1; }

		//"coldcc"
		public Keyword getColdccKeyword_2() { return cColdccKeyword_2; }

		//"x86_stdcallcc"
		public Keyword getX86_stdcallccKeyword_3() { return cX86_stdcallccKeyword_3; }

		//"x86_fastcallcc"
		public Keyword getX86_fastcallccKeyword_4() { return cX86_fastcallccKeyword_4; }

		//"x86_thiscallcc"
		public Keyword getX86_thiscallccKeyword_5() { return cX86_thiscallccKeyword_5; }

		//"arm_apcscc"
		public Keyword getArm_apcsccKeyword_6() { return cArm_apcsccKeyword_6; }

		//"arm_aapcscc"
		public Keyword getArm_aapcsccKeyword_7() { return cArm_aapcsccKeyword_7; }

		//"arm_aapcs_vfpcc"
		public Keyword getArm_aapcs_vfpccKeyword_8() { return cArm_aapcs_vfpccKeyword_8; }

		//"msp430_intrcc"
		public Keyword getMsp430_intrccKeyword_9() { return cMsp430_intrccKeyword_9; }

		//"ptx_kernel"
		public Keyword getPtx_kernelKeyword_10() { return cPtx_kernelKeyword_10; }

		//"ptx_device"
		public Keyword getPtx_deviceKeyword_11() { return cPtx_deviceKeyword_11; }

		//"spir_func"
		public Keyword getSpir_funcKeyword_12() { return cSpir_funcKeyword_12; }

		//"spir_kernel"
		public Keyword getSpir_kernelKeyword_13() { return cSpir_kernelKeyword_13; }

		//"cc" "<" INT ">" INT
		public Group getGroup_14() { return cGroup_14; }

		//"cc"
		public Keyword getCcKeyword_14_0() { return cCcKeyword_14_0; }

		//"<"
		public Keyword getLessThanSignKeyword_14_1() { return cLessThanSignKeyword_14_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_14_2() { return cINTTerminalRuleCall_14_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_14_3() { return cGreaterThanSignKeyword_14_3; }

		//INT
		public RuleCall getINTTerminalRuleCall_14_4() { return cINTTerminalRuleCall_14_4; }
	}

	public class FUNCTION_ATTRIBUTESElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FUNCTION_ATTRIBUTES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAddress_safetyKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cAlignstackKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Keyword cGreaterThanSignKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cRightParenthesisKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Keyword cAlwaysinlineKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cNonlazybindKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cInlinehintKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cNakedKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cNoimplicitfloatKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cNoinlineKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cNoredzoneKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cNoreturnKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cNounwindKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cOptsizeKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cReadnoneKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cReadonlyKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cReturns_twiceKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cSspKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cSspreqKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cUwtableKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		
		/// *
		//
		// * This is to summarize the possible function attributes
		//
		// * / FUNCTION_ATTRIBUTES:
		//
		//	"address_safety" | "alignstack" "(" "<" INT ">" ")" | "alwaysinline" | "nonlazybind" | "inlinehint" | "naked" |
		//
		//	"noimplicitfloat" | "noinline" | "noredzone" | "noreturn" | "nounwind" | "optsize" | "readnone" | "readonly" |
		//
		//	"returns_twice" | "ssp" | "sspreq" | "uwtable";
		public ParserRule getRule() { return rule; }

		//"address_safety" | "alignstack" "(" "<" INT ">" ")" | "alwaysinline" | "nonlazybind" | "inlinehint" | "naked" |
		//
		//"noimplicitfloat" | "noinline" | "noredzone" | "noreturn" | "nounwind" | "optsize" | "readnone" | "readonly" |
		//
		//"returns_twice" | "ssp" | "sspreq" | "uwtable"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"address_safety"
		public Keyword getAddress_safetyKeyword_0() { return cAddress_safetyKeyword_0; }

		//"alignstack" "(" "<" INT ">" ")"
		public Group getGroup_1() { return cGroup_1; }

		//"alignstack"
		public Keyword getAlignstackKeyword_1_0() { return cAlignstackKeyword_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_2() { return cLessThanSignKeyword_1_2; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_3() { return cINTTerminalRuleCall_1_3; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_4() { return cGreaterThanSignKeyword_1_4; }

		//")"
		public Keyword getRightParenthesisKeyword_1_5() { return cRightParenthesisKeyword_1_5; }

		//"alwaysinline"
		public Keyword getAlwaysinlineKeyword_2() { return cAlwaysinlineKeyword_2; }

		//"nonlazybind"
		public Keyword getNonlazybindKeyword_3() { return cNonlazybindKeyword_3; }

		//"inlinehint"
		public Keyword getInlinehintKeyword_4() { return cInlinehintKeyword_4; }

		//"naked"
		public Keyword getNakedKeyword_5() { return cNakedKeyword_5; }

		//"noimplicitfloat"
		public Keyword getNoimplicitfloatKeyword_6() { return cNoimplicitfloatKeyword_6; }

		//"noinline"
		public Keyword getNoinlineKeyword_7() { return cNoinlineKeyword_7; }

		//"noredzone"
		public Keyword getNoredzoneKeyword_8() { return cNoredzoneKeyword_8; }

		//"noreturn"
		public Keyword getNoreturnKeyword_9() { return cNoreturnKeyword_9; }

		//"nounwind"
		public Keyword getNounwindKeyword_10() { return cNounwindKeyword_10; }

		//"optsize"
		public Keyword getOptsizeKeyword_11() { return cOptsizeKeyword_11; }

		//"readnone"
		public Keyword getReadnoneKeyword_12() { return cReadnoneKeyword_12; }

		//"readonly"
		public Keyword getReadonlyKeyword_13() { return cReadonlyKeyword_13; }

		//"returns_twice"
		public Keyword getReturns_twiceKeyword_14() { return cReturns_twiceKeyword_14; }

		//"ssp"
		public Keyword getSspKeyword_15() { return cSspKeyword_15; }

		//"sspreq"
		public Keyword getSspreqKeyword_16() { return cSspreqKeyword_16; }

		//"uwtable"
		public Keyword getUwtableKeyword_17() { return cUwtableKeyword_17; }
	}

	public class PHIElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PHI");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPhiKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValuesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValuesValuePairParserRuleCall_3_0 = (RuleCall)cValuesAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Assignment cValuesAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cValuesValuePairParserRuleCall_5_2_0 = (RuleCall)cValuesAssignment_5_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5_3 = (Keyword)cGroup_5.eContents().get(3);
		
		/// *
		//
		// * The 'phi' instruction is used to implement the  node in the SSA graph representing the function.
		//
		// * / PHI:
		//
		//	"phi" Type "[" values+=ValuePair "]" ("," "[" values+=ValuePair "]")*;
		public ParserRule getRule() { return rule; }

		//"phi" Type "[" values+=ValuePair "]" ("," "[" values+=ValuePair "]")*
		public Group getGroup() { return cGroup; }

		//"phi"
		public Keyword getPhiKeyword_0() { return cPhiKeyword_0; }

		//Type
		public RuleCall getTypeParserRuleCall_1() { return cTypeParserRuleCall_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//values+=ValuePair
		public Assignment getValuesAssignment_3() { return cValuesAssignment_3; }

		//ValuePair
		public RuleCall getValuesValuePairParserRuleCall_3_0() { return cValuesValuePairParserRuleCall_3_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }

		//("," "[" values+=ValuePair "]")*
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_5_1() { return cLeftSquareBracketKeyword_5_1; }

		//values+=ValuePair
		public Assignment getValuesAssignment_5_2() { return cValuesAssignment_5_2; }

		//ValuePair
		public RuleCall getValuesValuePairParserRuleCall_5_2_0() { return cValuesValuePairParserRuleCall_5_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_5_3() { return cRightSquareBracketKeyword_5_3; }
	}

	public class ValuePairElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValuePair");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValue1Assignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValue1TypeParserRuleCall_0_0 = (RuleCall)cValue1Assignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValue2Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValue2TypeParserRuleCall_2_0 = (RuleCall)cValue2Assignment_2.eContents().get(0);
		
		/// *
		//
		// * This rule is used to bring in more clarity in some instructions
		//
		// * / ValuePair:
		//
		//	value1=Type "," value2=Type;
		public ParserRule getRule() { return rule; }

		//value1=Type "," value2=Type
		public Group getGroup() { return cGroup; }

		//value1=Type
		public Assignment getValue1Assignment_0() { return cValue1Assignment_0; }

		//Type
		public RuleCall getValue1TypeParserRuleCall_0_0() { return cValue1TypeParserRuleCall_0_0; }

		//","
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }

		//value2=Type
		public Assignment getValue2Assignment_2() { return cValue2Assignment_2; }

		//Type
		public RuleCall getValue2TypeParserRuleCall_2_0() { return cValue2TypeParserRuleCall_2_0; }
	}

	public class LandingPadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LandingPad");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLandingpadKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_0_1_0 = (RuleCall)cTypeAssignment_0_1.eContents().get(0);
		private final Keyword cPersonalityKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cPersonalityAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cPersonalityTypeAndValueParserRuleCall_0_3_0 = (RuleCall)cPersonalityAssignment_0_3.eContents().get(0);
		private final Alternatives cAlternatives_0_4 = (Alternatives)cGroup_0.eContents().get(4);
		private final Group cGroup_0_4_0 = (Group)cAlternatives_0_4.eContents().get(0);
		private final Keyword cCleanupKeyword_0_4_0_0 = (Keyword)cGroup_0_4_0.eContents().get(0);
		private final Assignment cClauseAssignment_0_4_0_1 = (Assignment)cGroup_0_4_0.eContents().get(1);
		private final RuleCall cClauseClauseParserRuleCall_0_4_0_1_0 = (RuleCall)cClauseAssignment_0_4_0_1.eContents().get(0);
		private final Assignment cClauseAssignment_0_4_1 = (Assignment)cAlternatives_0_4.eContents().get(1);
		private final RuleCall cClauseClauseParserRuleCall_0_4_1_0 = (RuleCall)cClauseAssignment_0_4_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLandingpadKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		private final Keyword cPersonalityKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cPersonalitytypeAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cPersonalitytypeTypeParserRuleCall_1_3_0 = (RuleCall)cPersonalitytypeAssignment_1_3.eContents().get(0);
		private final Assignment cPersonalityfunctionAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cPersonalityfunctionCAST_TYPEParserRuleCall_1_4_0 = (RuleCall)cPersonalityfunctionAssignment_1_4.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cValueAssignment_1_6 = (Assignment)cGroup_1.eContents().get(6);
		private final RuleCall cValueTypeParserRuleCall_1_6_0 = (RuleCall)cValueAssignment_1_6.eContents().get(0);
		private final Keyword cLeftParenthesisFullStopFullStopFullStopRightParenthesisAsteriskKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		private final RuleCall cVAR_TYPETerminalRuleCall_1_8 = (RuleCall)cGroup_1.eContents().get(8);
		private final Keyword cToKeyword_1_9 = (Keyword)cGroup_1.eContents().get(9);
		private final Assignment cCasttoAssignment_1_10 = (Assignment)cGroup_1.eContents().get(10);
		private final RuleCall cCasttoTypeParserRuleCall_1_10_0 = (RuleCall)cCasttoAssignment_1_10.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_11 = (Keyword)cGroup_1.eContents().get(11);
		private final Alternatives cAlternatives_1_12 = (Alternatives)cGroup_1.eContents().get(12);
		private final Group cGroup_1_12_0 = (Group)cAlternatives_1_12.eContents().get(0);
		private final Keyword cCleanupKeyword_1_12_0_0 = (Keyword)cGroup_1_12_0.eContents().get(0);
		private final Assignment cClauseAssignment_1_12_0_1 = (Assignment)cGroup_1_12_0.eContents().get(1);
		private final RuleCall cClauseClauseParserRuleCall_1_12_0_1_0 = (RuleCall)cClauseAssignment_1_12_0_1.eContents().get(0);
		private final Assignment cClauseAssignment_1_12_1 = (Assignment)cAlternatives_1_12.eContents().get(1);
		private final RuleCall cClauseClauseParserRuleCall_1_12_1_0 = (RuleCall)cClauseAssignment_1_12_1.eContents().get(0);
		
		/// *
		//
		// * The 'landingpad' instruction is used by LLVM's exception handling system to specify that a basic 
		//
		// * block is a landing pad  one where the exception lands, and corresponds to the code found in the 
		//
		// * catch portion of a try/catch sequence. It defines values supplied by the personality function (pers_fn)
		//
		// * upon re-entry to the function. The resultval has the type resultty.
		//
		// * / LandingPad:
		//
		//	"landingpad" type=Type "personality" personality=TypeAndValue ("cleanup" clause+=Clause* | clause+=Clause+) |
		//
		//	"landingpad" type=Type "personality" personalitytype=Type personalityfunction=CAST_TYPE "(" value=Type "(...)*"
		//
		//	VAR_TYPE "to" castto=Type ")" ("cleanup" clause+=Clause* | clause+=Clause+);
		public ParserRule getRule() { return rule; }

		//"landingpad" type=Type "personality" personality=TypeAndValue ("cleanup" clause+=Clause* | clause+=Clause+) |
		//
		//"landingpad" type=Type "personality" personalitytype=Type personalityfunction=CAST_TYPE "(" value=Type "(...)*"
		//
		//VAR_TYPE "to" castto=Type ")" ("cleanup" clause+=Clause* | clause+=Clause+)
		public Alternatives getAlternatives() { return cAlternatives; }

		//"landingpad" type=Type "personality" personality=TypeAndValue ("cleanup" clause+=Clause* | clause+=Clause+)
		public Group getGroup_0() { return cGroup_0; }

		//"landingpad"
		public Keyword getLandingpadKeyword_0_0() { return cLandingpadKeyword_0_0; }

		//type=Type
		public Assignment getTypeAssignment_0_1() { return cTypeAssignment_0_1; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_0_1_0() { return cTypeTypeParserRuleCall_0_1_0; }

		//"personality"
		public Keyword getPersonalityKeyword_0_2() { return cPersonalityKeyword_0_2; }

		//personality=TypeAndValue
		public Assignment getPersonalityAssignment_0_3() { return cPersonalityAssignment_0_3; }

		//TypeAndValue
		public RuleCall getPersonalityTypeAndValueParserRuleCall_0_3_0() { return cPersonalityTypeAndValueParserRuleCall_0_3_0; }

		//"cleanup" clause+=Clause* | clause+=Clause+
		public Alternatives getAlternatives_0_4() { return cAlternatives_0_4; }

		//"cleanup" clause+=Clause*
		public Group getGroup_0_4_0() { return cGroup_0_4_0; }

		//"cleanup"
		public Keyword getCleanupKeyword_0_4_0_0() { return cCleanupKeyword_0_4_0_0; }

		//clause+=Clause*
		public Assignment getClauseAssignment_0_4_0_1() { return cClauseAssignment_0_4_0_1; }

		//Clause
		public RuleCall getClauseClauseParserRuleCall_0_4_0_1_0() { return cClauseClauseParserRuleCall_0_4_0_1_0; }

		//clause+=Clause+
		public Assignment getClauseAssignment_0_4_1() { return cClauseAssignment_0_4_1; }

		//Clause
		public RuleCall getClauseClauseParserRuleCall_0_4_1_0() { return cClauseClauseParserRuleCall_0_4_1_0; }

		//"landingpad" type=Type "personality" personalitytype=Type personalityfunction=CAST_TYPE "(" value=Type "(...)*" VAR_TYPE
		//
		//"to" castto=Type ")" ("cleanup" clause+=Clause* | clause+=Clause+)
		public Group getGroup_1() { return cGroup_1; }

		//"landingpad"
		public Keyword getLandingpadKeyword_1_0() { return cLandingpadKeyword_1_0; }

		//type=Type
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_1_1_0() { return cTypeTypeParserRuleCall_1_1_0; }

		//"personality"
		public Keyword getPersonalityKeyword_1_2() { return cPersonalityKeyword_1_2; }

		//personalitytype=Type
		public Assignment getPersonalitytypeAssignment_1_3() { return cPersonalitytypeAssignment_1_3; }

		//Type
		public RuleCall getPersonalitytypeTypeParserRuleCall_1_3_0() { return cPersonalitytypeTypeParserRuleCall_1_3_0; }

		//personalityfunction=CAST_TYPE
		public Assignment getPersonalityfunctionAssignment_1_4() { return cPersonalityfunctionAssignment_1_4; }

		//CAST_TYPE
		public RuleCall getPersonalityfunctionCAST_TYPEParserRuleCall_1_4_0() { return cPersonalityfunctionCAST_TYPEParserRuleCall_1_4_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_5() { return cLeftParenthesisKeyword_1_5; }

		//value=Type
		public Assignment getValueAssignment_1_6() { return cValueAssignment_1_6; }

		//Type
		public RuleCall getValueTypeParserRuleCall_1_6_0() { return cValueTypeParserRuleCall_1_6_0; }

		//"(...)*"
		public Keyword getLeftParenthesisFullStopFullStopFullStopRightParenthesisAsteriskKeyword_1_7() { return cLeftParenthesisFullStopFullStopFullStopRightParenthesisAsteriskKeyword_1_7; }

		//VAR_TYPE
		public RuleCall getVAR_TYPETerminalRuleCall_1_8() { return cVAR_TYPETerminalRuleCall_1_8; }

		//"to"
		public Keyword getToKeyword_1_9() { return cToKeyword_1_9; }

		//castto=Type
		public Assignment getCasttoAssignment_1_10() { return cCasttoAssignment_1_10; }

		//Type
		public RuleCall getCasttoTypeParserRuleCall_1_10_0() { return cCasttoTypeParserRuleCall_1_10_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_11() { return cRightParenthesisKeyword_1_11; }

		//"cleanup" clause+=Clause* | clause+=Clause+
		public Alternatives getAlternatives_1_12() { return cAlternatives_1_12; }

		//"cleanup" clause+=Clause*
		public Group getGroup_1_12_0() { return cGroup_1_12_0; }

		//"cleanup"
		public Keyword getCleanupKeyword_1_12_0_0() { return cCleanupKeyword_1_12_0_0; }

		//clause+=Clause*
		public Assignment getClauseAssignment_1_12_0_1() { return cClauseAssignment_1_12_0_1; }

		//Clause
		public RuleCall getClauseClauseParserRuleCall_1_12_0_1_0() { return cClauseClauseParserRuleCall_1_12_0_1_0; }

		//clause+=Clause+
		public Assignment getClauseAssignment_1_12_1() { return cClauseAssignment_1_12_1; }

		//Clause
		public RuleCall getClauseClauseParserRuleCall_1_12_1_0() { return cClauseClauseParserRuleCall_1_12_1_0; }
	}

	public class ClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Clause");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cCatchKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cTypeAndValueParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cFilterKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cFilterAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cFilterTypeAndValueParserRuleCall_1_1_0 = (RuleCall)cFilterAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cFilterAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cFilterTypeAndValueParserRuleCall_1_2_1_0 = (RuleCall)cFilterAssignment_1_2_1.eContents().get(0);
		
		/// *
		//
		// * A clause begins with the clause type  catch or filter  and contains the global variable representing
		//
		// * the "type" that may be caught or filtered respectively. Unlike the catch clause, the filter clause takes
		//
		// * an array constant as its argument. Use "[0 x i8**] undef" for a filter which cannot throw. The 'landingpad'
		//
		// * instruction must contain at least one clause or the cleanup flag.
		//
		// * / Clause:
		//
		//	"catch" TypeAndValue | "filter" filter+=TypeAndValue ("," filter+=TypeAndValue)*;
		public ParserRule getRule() { return rule; }

		//"catch" TypeAndValue | "filter" filter+=TypeAndValue ("," filter+=TypeAndValue)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//"catch" TypeAndValue
		public Group getGroup_0() { return cGroup_0; }

		//"catch"
		public Keyword getCatchKeyword_0_0() { return cCatchKeyword_0_0; }

		//TypeAndValue
		public RuleCall getTypeAndValueParserRuleCall_0_1() { return cTypeAndValueParserRuleCall_0_1; }

		//"filter" filter+=TypeAndValue ("," filter+=TypeAndValue)*
		public Group getGroup_1() { return cGroup_1; }

		//"filter"
		public Keyword getFilterKeyword_1_0() { return cFilterKeyword_1_0; }

		//filter+=TypeAndValue
		public Assignment getFilterAssignment_1_1() { return cFilterAssignment_1_1; }

		//TypeAndValue
		public RuleCall getFilterTypeAndValueParserRuleCall_1_1_0() { return cFilterTypeAndValueParserRuleCall_1_1_0; }

		//("," filter+=TypeAndValue)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//","
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }

		//filter+=TypeAndValue
		public Assignment getFilterAssignment_1_2_1() { return cFilterAssignment_1_2_1; }

		//TypeAndValue
		public RuleCall getFilterTypeAndValueParserRuleCall_1_2_1_0() { return cFilterTypeAndValueParserRuleCall_1_2_1_0; }
	}

	public class SelectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Select");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSelectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionTypeAndValueParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVal1Assignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVal1TypeAndValueParserRuleCall_3_0 = (RuleCall)cVal1Assignment_3.eContents().get(0);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cVal2Assignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cVal2TypeAndValueParserRuleCall_5_0 = (RuleCall)cVal2Assignment_5.eContents().get(0);
		
		/// *
		//
		// * The 'select' instruction is used to choose one value based on a condition, without branching.
		//
		// * / Select:
		//
		//	"select" condition=TypeAndValue "," val1=TypeAndValue "," val2=TypeAndValue;
		public ParserRule getRule() { return rule; }

		//"select" condition=TypeAndValue "," val1=TypeAndValue "," val2=TypeAndValue
		public Group getGroup() { return cGroup; }

		//"select"
		public Keyword getSelectKeyword_0() { return cSelectKeyword_0; }

		//condition=TypeAndValue
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//TypeAndValue
		public RuleCall getConditionTypeAndValueParserRuleCall_1_0() { return cConditionTypeAndValueParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//val1=TypeAndValue
		public Assignment getVal1Assignment_3() { return cVal1Assignment_3; }

		//TypeAndValue
		public RuleCall getVal1TypeAndValueParserRuleCall_3_0() { return cVal1TypeAndValueParserRuleCall_3_0; }

		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }

		//val2=TypeAndValue
		public Assignment getVal2Assignment_5() { return cVal2Assignment_5; }

		//TypeAndValue
		public RuleCall getVal2TypeAndValueParserRuleCall_5_0() { return cVal2TypeAndValueParserRuleCall_5_0; }
	}

	public class VA_ArgElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VA_Arg");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVa_argKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cListTypeAndValueParserRuleCall_1_0 = (RuleCall)cListAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cArgTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cArgTypeTypeParserRuleCall_3_0 = (RuleCall)cArgTypeAssignment_3.eContents().get(0);
		
		/// *
		//
		// * The 'va_arg' instruction is used to access arguments passed through the "variable argument" area of a 
		//
		// * function call. It is used to implement the va_arg macro in C.
		//
		// * / VA_Arg:
		//
		//	"va_arg" list=TypeAndValue "," argType=Type;
		public ParserRule getRule() { return rule; }

		//"va_arg" list=TypeAndValue "," argType=Type
		public Group getGroup() { return cGroup; }

		//"va_arg"
		public Keyword getVa_argKeyword_0() { return cVa_argKeyword_0; }

		//list=TypeAndValue
		public Assignment getListAssignment_1() { return cListAssignment_1; }

		//TypeAndValue
		public RuleCall getListTypeAndValueParserRuleCall_1_0() { return cListTypeAndValueParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//argType=Type
		public Assignment getArgTypeAssignment_3() { return cArgTypeAssignment_3; }

		//Type
		public RuleCall getArgTypeTypeParserRuleCall_3_0() { return cArgTypeTypeParserRuleCall_3_0; }
	}

	public class ExtractElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExtractElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExtractelementKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVectorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVectorTypeAndValueParserRuleCall_1_0 = (RuleCall)cVectorAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIndexAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIndexTypeAndValueParserRuleCall_3_0 = (RuleCall)cIndexAssignment_3.eContents().get(0);
		
		/// *
		//
		// * The 'extractelement' instruction extracts a single scalar element from a vector at a specified index.
		//
		// * / ExtractElement:
		//
		//	"extractelement" vector=TypeAndValue "," index=TypeAndValue;
		public ParserRule getRule() { return rule; }

		//"extractelement" vector=TypeAndValue "," index=TypeAndValue
		public Group getGroup() { return cGroup; }

		//"extractelement"
		public Keyword getExtractelementKeyword_0() { return cExtractelementKeyword_0; }

		//vector=TypeAndValue
		public Assignment getVectorAssignment_1() { return cVectorAssignment_1; }

		//TypeAndValue
		public RuleCall getVectorTypeAndValueParserRuleCall_1_0() { return cVectorTypeAndValueParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//index=TypeAndValue
		public Assignment getIndexAssignment_3() { return cIndexAssignment_3; }

		//TypeAndValue
		public RuleCall getIndexTypeAndValueParserRuleCall_3_0() { return cIndexTypeAndValueParserRuleCall_3_0; }
	}

	public class InsertElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InsertElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInsertelementKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVectorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVectorTypeAndValueParserRuleCall_1_0 = (RuleCall)cVectorAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cScalarAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cScalarTypeAndValueParserRuleCall_3_0 = (RuleCall)cScalarAssignment_3.eContents().get(0);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cIndexAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cIndexTypeAndValueParserRuleCall_5_0 = (RuleCall)cIndexAssignment_5.eContents().get(0);
		
		/// *
		//
		// * The 'insertelement' instruction inserts a scalar element into a vector at a specified index.
		//
		// * / InsertElement:
		//
		//	"insertelement" vector=TypeAndValue "," scalar=TypeAndValue "," index=TypeAndValue;
		public ParserRule getRule() { return rule; }

		//"insertelement" vector=TypeAndValue "," scalar=TypeAndValue "," index=TypeAndValue
		public Group getGroup() { return cGroup; }

		//"insertelement"
		public Keyword getInsertelementKeyword_0() { return cInsertelementKeyword_0; }

		//vector=TypeAndValue
		public Assignment getVectorAssignment_1() { return cVectorAssignment_1; }

		//TypeAndValue
		public RuleCall getVectorTypeAndValueParserRuleCall_1_0() { return cVectorTypeAndValueParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//scalar=TypeAndValue
		public Assignment getScalarAssignment_3() { return cScalarAssignment_3; }

		//TypeAndValue
		public RuleCall getScalarTypeAndValueParserRuleCall_3_0() { return cScalarTypeAndValueParserRuleCall_3_0; }

		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }

		//index=TypeAndValue
		public Assignment getIndexAssignment_5() { return cIndexAssignment_5; }

		//TypeAndValue
		public RuleCall getIndexTypeAndValueParserRuleCall_5_0() { return cIndexTypeAndValueParserRuleCall_5_0; }
	}

	public class ShuffleVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ShuffleVector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cShufflevectorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVector1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVector1TypeAndValueParserRuleCall_1_0 = (RuleCall)cVector1Assignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVector2Assignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVector2TypeAndValueParserRuleCall_3_0 = (RuleCall)cVector2Assignment_3.eContents().get(0);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cMaskAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cMaskTypeAndValueParserRuleCall_5_0 = (RuleCall)cMaskAssignment_5.eContents().get(0);
		
		/// *
		//
		// * The 'shufflevector' instruction constructs a permutation of elements from two input vectors, 
		//
		// * returning a vector with the same element type as the input and length that is the same as the shuffle mask.
		//
		// * / ShuffleVector:
		//
		//	"shufflevector" vector1=TypeAndValue "," vector2=TypeAndValue "," mask=TypeAndValue;
		public ParserRule getRule() { return rule; }

		//"shufflevector" vector1=TypeAndValue "," vector2=TypeAndValue "," mask=TypeAndValue
		public Group getGroup() { return cGroup; }

		//"shufflevector"
		public Keyword getShufflevectorKeyword_0() { return cShufflevectorKeyword_0; }

		//vector1=TypeAndValue
		public Assignment getVector1Assignment_1() { return cVector1Assignment_1; }

		//TypeAndValue
		public RuleCall getVector1TypeAndValueParserRuleCall_1_0() { return cVector1TypeAndValueParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//vector2=TypeAndValue
		public Assignment getVector2Assignment_3() { return cVector2Assignment_3; }

		//TypeAndValue
		public RuleCall getVector2TypeAndValueParserRuleCall_3_0() { return cVector2TypeAndValueParserRuleCall_3_0; }

		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }

		//mask=TypeAndValue
		public Assignment getMaskAssignment_5() { return cMaskAssignment_5; }

		//TypeAndValue
		public RuleCall getMaskTypeAndValueParserRuleCall_5_0() { return cMaskTypeAndValueParserRuleCall_5_0; }
	}

	public class CastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Cast");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCAST_TYPEParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueTypeAndValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Keyword cToKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCasttoAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCasttoTypeParserRuleCall_3_0 = (RuleCall)cCasttoAssignment_3.eContents().get(0);
		
		/// *
		//
		// * This rule is to provide a typecast. Nothing special
		//
		// * Example
		//
		// *  %X = trunc i32 257 to i8
		//
		// *  %Z = fptosi float 1.04E+17 to i8
		//
		// * / Cast:
		//
		//	CAST_TYPE value=TypeAndValue "to" castto=Type;
		public ParserRule getRule() { return rule; }

		//CAST_TYPE value=TypeAndValue "to" castto=Type
		public Group getGroup() { return cGroup; }

		//CAST_TYPE
		public RuleCall getCAST_TYPEParserRuleCall_0() { return cCAST_TYPEParserRuleCall_0; }

		//value=TypeAndValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//TypeAndValue
		public RuleCall getValueTypeAndValueParserRuleCall_1_0() { return cValueTypeAndValueParserRuleCall_1_0; }

		//"to"
		public Keyword getToKeyword_2() { return cToKeyword_2; }

		//castto=Type
		public Assignment getCasttoAssignment_3() { return cCasttoAssignment_3; }

		//Type
		public RuleCall getCasttoTypeParserRuleCall_3_0() { return cCasttoTypeParserRuleCall_3_0; }
	}

	public class CAST_TYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CAST_TYPE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTruncKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cZextKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSextKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cFptruncKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cFpextKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cFptouiKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cFptosiKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cUitofpKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cSitofpKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cPtrtointKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cInttoptrKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cBitcastKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		
		/// *
		//
		// * The instructions in this category are the conversion instructions (casting) which
		//
		// * all take a single operand and a type. They perform various bit conversions on the operand.
		//
		// * / CAST_TYPE:
		//
		//	"trunc" | "zext" | "sext" | "fptrunc" | "fpext" | "fptoui" | "fptosi" | "uitofp" | "sitofp" | "ptrtoint" | "inttoptr"
		//
		//	| "bitcast";
		public ParserRule getRule() { return rule; }

		//"trunc" | "zext" | "sext" | "fptrunc" | "fpext" | "fptoui" | "fptosi" | "uitofp" | "sitofp" | "ptrtoint" | "inttoptr" |
		//
		//"bitcast"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"trunc"
		public Keyword getTruncKeyword_0() { return cTruncKeyword_0; }

		//"zext"
		public Keyword getZextKeyword_1() { return cZextKeyword_1; }

		//"sext"
		public Keyword getSextKeyword_2() { return cSextKeyword_2; }

		//"fptrunc"
		public Keyword getFptruncKeyword_3() { return cFptruncKeyword_3; }

		//"fpext"
		public Keyword getFpextKeyword_4() { return cFpextKeyword_4; }

		//"fptoui"
		public Keyword getFptouiKeyword_5() { return cFptouiKeyword_5; }

		//"fptosi"
		public Keyword getFptosiKeyword_6() { return cFptosiKeyword_6; }

		//"uitofp"
		public Keyword getUitofpKeyword_7() { return cUitofpKeyword_7; }

		//"sitofp"
		public Keyword getSitofpKeyword_8() { return cSitofpKeyword_8; }

		//"ptrtoint"
		public Keyword getPtrtointKeyword_9() { return cPtrtointKeyword_9; }

		//"inttoptr"
		public Keyword getInttoptrKeyword_10() { return cInttoptrKeyword_10; }

		//"bitcast"
		public Keyword getBitcastKeyword_11() { return cBitcastKeyword_11; }
	}

	public class CompareElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Compare");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cIcmpKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cI_PREDICATESParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cTypeParserRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final RuleCall cValuePairParserRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cFcmpKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cF_PREDICATESParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cTypeParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final RuleCall cValuePairParserRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		
		/// *
		//
		// * The 'icmp' instruction returns a boolean value or a vector of boolean values based on comparison of 
		//
		// * 		its two integer, integer vector, pointer, or pointer vector operands.
		//
		// * The 'fcmp' instruction returns a boolean value or vector of boolean values based on comparison of its operands.
		//
		// * / Compare:
		//
		//	"icmp" I_PREDICATES Type ValuePair | "fcmp" F_PREDICATES Type ValuePair;
		public ParserRule getRule() { return rule; }

		//"icmp" I_PREDICATES Type ValuePair | "fcmp" F_PREDICATES Type ValuePair
		public Alternatives getAlternatives() { return cAlternatives; }

		//"icmp" I_PREDICATES Type ValuePair
		public Group getGroup_0() { return cGroup_0; }

		//"icmp"
		public Keyword getIcmpKeyword_0_0() { return cIcmpKeyword_0_0; }

		//I_PREDICATES
		public RuleCall getI_PREDICATESParserRuleCall_0_1() { return cI_PREDICATESParserRuleCall_0_1; }

		//Type
		public RuleCall getTypeParserRuleCall_0_2() { return cTypeParserRuleCall_0_2; }

		//ValuePair
		public RuleCall getValuePairParserRuleCall_0_3() { return cValuePairParserRuleCall_0_3; }

		//"fcmp" F_PREDICATES Type ValuePair
		public Group getGroup_1() { return cGroup_1; }

		//"fcmp"
		public Keyword getFcmpKeyword_1_0() { return cFcmpKeyword_1_0; }

		//F_PREDICATES
		public RuleCall getF_PREDICATESParserRuleCall_1_1() { return cF_PREDICATESParserRuleCall_1_1; }

		//Type
		public RuleCall getTypeParserRuleCall_1_2() { return cTypeParserRuleCall_1_2; }

		//ValuePair
		public RuleCall getValuePairParserRuleCall_1_3() { return cValuePairParserRuleCall_1_3; }
	}

	public class I_PREDICATESElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "I_PREDICATES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNeKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cUgtKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cUgeKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cUltKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cUleKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cSgtKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cSgeKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cSltKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cSleKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		
		/// *
		//
		// * This is to summarize the possible Integer Predicates
		//
		// * / I_PREDICATES:
		//
		//	"eq" | "ne" | "ugt" | "uge" | "ult" | "ule" | "sgt" | "sge" | "slt" | "sle";
		public ParserRule getRule() { return rule; }

		//"eq" | "ne" | "ugt" | "uge" | "ult" | "ule" | "sgt" | "sge" | "slt" | "sle"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"eq"
		public Keyword getEqKeyword_0() { return cEqKeyword_0; }

		//"ne"
		public Keyword getNeKeyword_1() { return cNeKeyword_1; }

		//"ugt"
		public Keyword getUgtKeyword_2() { return cUgtKeyword_2; }

		//"uge"
		public Keyword getUgeKeyword_3() { return cUgeKeyword_3; }

		//"ult"
		public Keyword getUltKeyword_4() { return cUltKeyword_4; }

		//"ule"
		public Keyword getUleKeyword_5() { return cUleKeyword_5; }

		//"sgt"
		public Keyword getSgtKeyword_6() { return cSgtKeyword_6; }

		//"sge"
		public Keyword getSgeKeyword_7() { return cSgeKeyword_7; }

		//"slt"
		public Keyword getSltKeyword_8() { return cSltKeyword_8; }

		//"sle"
		public Keyword getSleKeyword_9() { return cSleKeyword_9; }
	}

	public class F_PREDICATESElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "F_PREDICATES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFalseKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cOeqKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cOgtKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cOgeKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cOltKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cOleKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cOneKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cOrdKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cUeqKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cUgtKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cUgeKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cUltKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cUleKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cUneKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cUnoKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cTrueKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		
		/// *
		//
		// * This is to summarize the possible Floating Predicates
		//
		// * / F_PREDICATES:
		//
		//	"false" | "oeq" | "ogt" | "oge" | "olt" | "ole" | "one" | "ord" | "ueq" | "ugt" | "uge" | "ult" | "ule" | "une" |
		//
		//	"uno" | "true";
		public ParserRule getRule() { return rule; }

		//"false" | "oeq" | "ogt" | "oge" | "olt" | "ole" | "one" | "ord" | "ueq" | "ugt" | "uge" | "ult" | "ule" | "une" | "uno"
		//
		//| "true"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"false"
		public Keyword getFalseKeyword_0() { return cFalseKeyword_0; }

		//"oeq"
		public Keyword getOeqKeyword_1() { return cOeqKeyword_1; }

		//"ogt"
		public Keyword getOgtKeyword_2() { return cOgtKeyword_2; }

		//"oge"
		public Keyword getOgeKeyword_3() { return cOgeKeyword_3; }

		//"olt"
		public Keyword getOltKeyword_4() { return cOltKeyword_4; }

		//"ole"
		public Keyword getOleKeyword_5() { return cOleKeyword_5; }

		//"one"
		public Keyword getOneKeyword_6() { return cOneKeyword_6; }

		//"ord"
		public Keyword getOrdKeyword_7() { return cOrdKeyword_7; }

		//"ueq"
		public Keyword getUeqKeyword_8() { return cUeqKeyword_8; }

		//"ugt"
		public Keyword getUgtKeyword_9() { return cUgtKeyword_9; }

		//"uge"
		public Keyword getUgeKeyword_10() { return cUgeKeyword_10; }

		//"ult"
		public Keyword getUltKeyword_11() { return cUltKeyword_11; }

		//"ule"
		public Keyword getUleKeyword_12() { return cUleKeyword_12; }

		//"une"
		public Keyword getUneKeyword_13() { return cUneKeyword_13; }

		//"uno"
		public Keyword getUnoKeyword_14() { return cUnoKeyword_14; }

		//"true"
		public Keyword getTrueKeyword_15() { return cTrueKeyword_15; }
	}

	public class ARITHMETIC_OPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ARITHMETIC_OP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cAddKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cFaddKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cSubKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final Keyword cFsubKeyword_0_3 = (Keyword)cAlternatives_0.eContents().get(3);
		private final Keyword cMulKeyword_0_4 = (Keyword)cAlternatives_0.eContents().get(4);
		private final Keyword cFmulKeyword_0_5 = (Keyword)cAlternatives_0.eContents().get(5);
		private final Keyword cUdivKeyword_0_6 = (Keyword)cAlternatives_0.eContents().get(6);
		private final Keyword cSdivKeyword_0_7 = (Keyword)cAlternatives_0.eContents().get(7);
		private final Keyword cFdivKeyword_0_8 = (Keyword)cAlternatives_0.eContents().get(8);
		private final Keyword cUremKeyword_0_9 = (Keyword)cAlternatives_0.eContents().get(9);
		private final Keyword cSremKeyword_0_10 = (Keyword)cAlternatives_0.eContents().get(10);
		private final Keyword cFremKeyword_0_11 = (Keyword)cAlternatives_0.eContents().get(11);
		private final RuleCall cTypeParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cValuePairParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// *
		//
		// * This is to summarize the possible Arithmetic Operations
		//
		// * / ARITHMETIC_OP:
		//
		//	("add" | "fadd" | "sub" | "fsub" | "mul" | "fmul" | "udiv" | "sdiv" | "fdiv" | "urem" | "srem" | "frem") Type
		//
		//	ValuePair;
		public ParserRule getRule() { return rule; }

		//("add" | "fadd" | "sub" | "fsub" | "mul" | "fmul" | "udiv" | "sdiv" | "fdiv" | "urem" | "srem" | "frem") Type ValuePair
		public Group getGroup() { return cGroup; }

		//"add" | "fadd" | "sub" | "fsub" | "mul" | "fmul" | "udiv" | "sdiv" | "fdiv" | "urem" | "srem" | "frem"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"add"
		public Keyword getAddKeyword_0_0() { return cAddKeyword_0_0; }

		//"fadd"
		public Keyword getFaddKeyword_0_1() { return cFaddKeyword_0_1; }

		//"sub"
		public Keyword getSubKeyword_0_2() { return cSubKeyword_0_2; }

		//"fsub"
		public Keyword getFsubKeyword_0_3() { return cFsubKeyword_0_3; }

		//"mul"
		public Keyword getMulKeyword_0_4() { return cMulKeyword_0_4; }

		//"fmul"
		public Keyword getFmulKeyword_0_5() { return cFmulKeyword_0_5; }

		//"udiv"
		public Keyword getUdivKeyword_0_6() { return cUdivKeyword_0_6; }

		//"sdiv"
		public Keyword getSdivKeyword_0_7() { return cSdivKeyword_0_7; }

		//"fdiv"
		public Keyword getFdivKeyword_0_8() { return cFdivKeyword_0_8; }

		//"urem"
		public Keyword getUremKeyword_0_9() { return cUremKeyword_0_9; }

		//"srem"
		public Keyword getSremKeyword_0_10() { return cSremKeyword_0_10; }

		//"frem"
		public Keyword getFremKeyword_0_11() { return cFremKeyword_0_11; }

		//Type
		public RuleCall getTypeParserRuleCall_1() { return cTypeParserRuleCall_1; }

		//ValuePair
		public RuleCall getValuePairParserRuleCall_2() { return cValuePairParserRuleCall_2; }
	}

	public class LOGICAL_OPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LOGICAL_OP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cShlKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cLshrKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cAshrKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final Keyword cAndKeyword_0_3 = (Keyword)cAlternatives_0.eContents().get(3);
		private final Keyword cOrKeyword_0_4 = (Keyword)cAlternatives_0.eContents().get(4);
		private final Keyword cXorKeyword_0_5 = (Keyword)cAlternatives_0.eContents().get(5);
		private final RuleCall cTypeParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cValuePairParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// *
		//
		// * This is to summarize the possible Logical Operations
		//
		// * / LOGICAL_OP:
		//
		//	("shl" | "lshr" | "ashr" | "and" | "or" | "xor") Type ValuePair;
		public ParserRule getRule() { return rule; }

		//("shl" | "lshr" | "ashr" | "and" | "or" | "xor") Type ValuePair
		public Group getGroup() { return cGroup; }

		//"shl" | "lshr" | "ashr" | "and" | "or" | "xor"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"shl"
		public Keyword getShlKeyword_0_0() { return cShlKeyword_0_0; }

		//"lshr"
		public Keyword getLshrKeyword_0_1() { return cLshrKeyword_0_1; }

		//"ashr"
		public Keyword getAshrKeyword_0_2() { return cAshrKeyword_0_2; }

		//"and"
		public Keyword getAndKeyword_0_3() { return cAndKeyword_0_3; }

		//"or"
		public Keyword getOrKeyword_0_4() { return cOrKeyword_0_4; }

		//"xor"
		public Keyword getXorKeyword_0_5() { return cXorKeyword_0_5; }

		//Type
		public RuleCall getTypeParserRuleCall_1() { return cTypeParserRuleCall_1; }

		//ValuePair
		public RuleCall getValuePairParserRuleCall_2() { return cValuePairParserRuleCall_2; }
	}

	public class InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Instruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cVolatileKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cLoadParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cVolatileKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cStoreParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cFenceParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cGetElementPtrParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cLOGICAL_OPParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cARITHMETIC_OPParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cCompareParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cCastParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cShuffleVectorParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cInsertElementParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cExtractElementParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cInsertValueParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cExtractValueParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cAllocParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cCmpXchgParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cAtomicRMWParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cPHIParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		private final RuleCall cSelectParserRuleCall_17 = (RuleCall)cAlternatives.eContents().get(17);
		private final RuleCall cCallParserRuleCall_18 = (RuleCall)cAlternatives.eContents().get(18);
		private final RuleCall cVA_ArgParserRuleCall_19 = (RuleCall)cAlternatives.eContents().get(19);
		private final RuleCall cLandingPadParserRuleCall_20 = (RuleCall)cAlternatives.eContents().get(20);
		private final RuleCall cLocalVarParserRuleCall_21 = (RuleCall)cAlternatives.eContents().get(21);
		
		/// *
		//
		// * This is only to summarize all possible Instructions
		//
		// * / Instruction:
		//
		//	"volatile"? Load | "volatile"? Store | Fence | GetElementPtr | LOGICAL_OP | ARITHMETIC_OP | Compare | Cast |
		//
		//	ShuffleVector | InsertElement | ExtractElement | InsertValue | ExtractValue | Alloc | CmpXchg | AtomicRMW | PHI |
		//
		//	Select | Call | VA_Arg | LandingPad | LocalVar;
		public ParserRule getRule() { return rule; }

		//"volatile"? Load | "volatile"? Store | Fence | GetElementPtr | LOGICAL_OP | ARITHMETIC_OP | Compare | Cast |
		//
		//ShuffleVector | InsertElement | ExtractElement | InsertValue | ExtractValue | Alloc | CmpXchg | AtomicRMW | PHI |
		//
		//Select | Call | VA_Arg | LandingPad | LocalVar
		public Alternatives getAlternatives() { return cAlternatives; }

		//"volatile"? Load
		public Group getGroup_0() { return cGroup_0; }

		//"volatile"?
		public Keyword getVolatileKeyword_0_0() { return cVolatileKeyword_0_0; }

		//Load
		public RuleCall getLoadParserRuleCall_0_1() { return cLoadParserRuleCall_0_1; }

		//"volatile"? Store
		public Group getGroup_1() { return cGroup_1; }

		//"volatile"?
		public Keyword getVolatileKeyword_1_0() { return cVolatileKeyword_1_0; }

		//Store
		public RuleCall getStoreParserRuleCall_1_1() { return cStoreParserRuleCall_1_1; }

		//Fence
		public RuleCall getFenceParserRuleCall_2() { return cFenceParserRuleCall_2; }

		//GetElementPtr
		public RuleCall getGetElementPtrParserRuleCall_3() { return cGetElementPtrParserRuleCall_3; }

		//LOGICAL_OP
		public RuleCall getLOGICAL_OPParserRuleCall_4() { return cLOGICAL_OPParserRuleCall_4; }

		//ARITHMETIC_OP
		public RuleCall getARITHMETIC_OPParserRuleCall_5() { return cARITHMETIC_OPParserRuleCall_5; }

		//Compare
		public RuleCall getCompareParserRuleCall_6() { return cCompareParserRuleCall_6; }

		//Cast
		public RuleCall getCastParserRuleCall_7() { return cCastParserRuleCall_7; }

		//ShuffleVector
		public RuleCall getShuffleVectorParserRuleCall_8() { return cShuffleVectorParserRuleCall_8; }

		//InsertElement
		public RuleCall getInsertElementParserRuleCall_9() { return cInsertElementParserRuleCall_9; }

		//ExtractElement
		public RuleCall getExtractElementParserRuleCall_10() { return cExtractElementParserRuleCall_10; }

		//InsertValue
		public RuleCall getInsertValueParserRuleCall_11() { return cInsertValueParserRuleCall_11; }

		//ExtractValue
		public RuleCall getExtractValueParserRuleCall_12() { return cExtractValueParserRuleCall_12; }

		//Alloc
		public RuleCall getAllocParserRuleCall_13() { return cAllocParserRuleCall_13; }

		//CmpXchg
		public RuleCall getCmpXchgParserRuleCall_14() { return cCmpXchgParserRuleCall_14; }

		//AtomicRMW
		public RuleCall getAtomicRMWParserRuleCall_15() { return cAtomicRMWParserRuleCall_15; }

		//PHI
		public RuleCall getPHIParserRuleCall_16() { return cPHIParserRuleCall_16; }

		//Select
		public RuleCall getSelectParserRuleCall_17() { return cSelectParserRuleCall_17; }

		//Call
		public RuleCall getCallParserRuleCall_18() { return cCallParserRuleCall_18; }

		//VA_Arg
		public RuleCall getVA_ArgParserRuleCall_19() { return cVA_ArgParserRuleCall_19; }

		//LandingPad
		public RuleCall getLandingPadParserRuleCall_20() { return cLandingPadParserRuleCall_20; }

		//LocalVar
		public RuleCall getLocalVarParserRuleCall_21() { return cLocalVarParserRuleCall_21; }
	}

	public class IndirectBranchElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IndirectBranch");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIndirectbrKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAdressAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAdressTypeAndValueParserRuleCall_1_0 = (RuleCall)cAdressAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cLListAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLListLabelListParserRuleCall_4_0 = (RuleCall)cLListAssignment_4.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		/// *
		//
		// * The 'indirectbr' instruction implements an indirect branch to a label within the current function, whose 
		//
		// * address is specified by "address". Address must be derived from a blockaddress constant.
		//
		// * / IndirectBranch:
		//
		//	"indirectbr" adress=TypeAndValue "," "[" lList=LabelList? "]";
		public ParserRule getRule() { return rule; }

		//"indirectbr" adress=TypeAndValue "," "[" lList=LabelList? "]"
		public Group getGroup() { return cGroup; }

		//"indirectbr"
		public Keyword getIndirectbrKeyword_0() { return cIndirectbrKeyword_0; }

		//adress=TypeAndValue
		public Assignment getAdressAssignment_1() { return cAdressAssignment_1; }

		//TypeAndValue
		public RuleCall getAdressTypeAndValueParserRuleCall_1_0() { return cAdressTypeAndValueParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_3() { return cLeftSquareBracketKeyword_3; }

		//lList=LabelList?
		public Assignment getLListAssignment_4() { return cLListAssignment_4; }

		//LabelList
		public RuleCall getLListLabelListParserRuleCall_4_0() { return cLListLabelListParserRuleCall_4_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_5() { return cRightSquareBracketKeyword_5; }
	}

	public class LabelListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LabelList");
		private final Assignment cLabelsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cLabelsTypeAndValueParserRuleCall_0 = (RuleCall)cLabelsAssignment.eContents().get(0);
		
		/// *
		//
		// * The Indirect Branch instruction needs a List of labels to jump to. 
		//
		// * This List is created here an contains Pairs of Types and Values
		//
		// * / LabelList:
		//
		//	labels+=TypeAndValue+;
		public ParserRule getRule() { return rule; }

		//labels+=TypeAndValue+
		public Assignment getLabelsAssignment() { return cLabelsAssignment; }

		//TypeAndValue
		public RuleCall getLabelsTypeAndValueParserRuleCall_0() { return cLabelsTypeAndValueParserRuleCall_0; }
	}

	public class SwitchElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Switch");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSwitchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueTypeAndValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDefaultAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDefaultTypeAndValueParserRuleCall_3_0 = (RuleCall)cDefaultAssignment_3.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cJTableAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cJTableJumpTableParserRuleCall_5_0 = (RuleCall)cJTableAssignment_5.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		/// *
		//
		// * The 'switch' instruction is used to transfer control flow to one of several different places. It is a generalization of 
		//
		// * the 'br' instruction, allowing a branch to occur to one of many possible destinations.
		//
		// * / Switch:
		//
		//	"switch" value=TypeAndValue "," default=TypeAndValue "[" jTable=JumpTable? "]";
		public ParserRule getRule() { return rule; }

		//"switch" value=TypeAndValue "," default=TypeAndValue "[" jTable=JumpTable? "]"
		public Group getGroup() { return cGroup; }

		//"switch"
		public Keyword getSwitchKeyword_0() { return cSwitchKeyword_0; }

		//value=TypeAndValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//TypeAndValue
		public RuleCall getValueTypeAndValueParserRuleCall_1_0() { return cValueTypeAndValueParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//default=TypeAndValue
		public Assignment getDefaultAssignment_3() { return cDefaultAssignment_3; }

		//TypeAndValue
		public RuleCall getDefaultTypeAndValueParserRuleCall_3_0() { return cDefaultTypeAndValueParserRuleCall_3_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_4() { return cLeftSquareBracketKeyword_4; }

		//jTable=JumpTable?
		public Assignment getJTableAssignment_5() { return cJTableAssignment_5; }

		//JumpTable
		public RuleCall getJTableJumpTableParserRuleCall_5_0() { return cJTableJumpTableParserRuleCall_5_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_6() { return cRightSquareBracketKeyword_6; }
	}

	public class JumpTableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "JumpTable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValuesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValuesTypeAndValueParserRuleCall_0_0 = (RuleCall)cValuesAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDestinationsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDestinationsTypeAndValueParserRuleCall_2_0 = (RuleCall)cDestinationsAssignment_2.eContents().get(0);
		
		/// *
		//
		// * The Switch instruction needs a list of values and destination, that will be jumped in case of value occures
		//
		// * / JumpTable:
		//
		//	(values+=TypeAndValue "," destinations+=TypeAndValue)+;
		public ParserRule getRule() { return rule; }

		//(values+=TypeAndValue "," destinations+=TypeAndValue)+
		public Group getGroup() { return cGroup; }

		//values+=TypeAndValue
		public Assignment getValuesAssignment_0() { return cValuesAssignment_0; }

		//TypeAndValue
		public RuleCall getValuesTypeAndValueParserRuleCall_0_0() { return cValuesTypeAndValueParserRuleCall_0_0; }

		//","
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }

		//destinations+=TypeAndValue
		public Assignment getDestinationsAssignment_2() { return cDestinationsAssignment_2; }

		//TypeAndValue
		public RuleCall getDestinationsTypeAndValueParserRuleCall_2_0() { return cDestinationsTypeAndValueParserRuleCall_2_0; }
	}

	public class InvokeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Invoke");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInvokeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cCallingConvParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cFunctionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFunctionTypeAndValueParserRuleCall_3_0 = (RuleCall)cFunctionAssignment_3.eContents().get(0);
		private final Assignment cPListAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPListParameterListParserRuleCall_4_0 = (RuleCall)cPListAssignment_4.eContents().get(0);
		private final RuleCall cFUNCTION_ATTRIBUTESParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Keyword cToKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cToAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cToTypeAndValueParserRuleCall_7_0 = (RuleCall)cToAssignment_7.eContents().get(0);
		private final Keyword cUnwindKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cUnwindAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cUnwindTypeAndValueParserRuleCall_9_0 = (RuleCall)cUnwindAssignment_9.eContents().get(0);
		
		/// *
		//
		// * The 'invoke' instruction causes control to transfer to a specified function, with the possibility of 
		//
		// * control flow transfer to either the 'normal' label or the 'exception' label. If the callee function 
		//
		// * returns with the "ret" instruction, control flow will return to the "normal" label. If the callee 
		//
		// * (or any indirect callees) returns via the "resume" instruction or other exception handling mechanism, 
		//
		// * control is interrupted and continued at the dynamically nearest "exception" label.
		//
		// * 
		//
		// * The 'exception' label is a landing pad for the exception. As such, 'exception' label is required to
		//
		// *  have the "landingpad" instruction, which contains the information about the behavior of the program 
		//
		// * after unwinding happens, as its first non-PHI instruction. The restrictions on the "landingpad" 
		//
		// * instruction's tightly couples it to the "invoke" instruction, so that the important information contained 
		//
		// * within the "landingpad" instruction can't be lost through normal code motion.
		//
		// * / Invoke:
		//
		//	"invoke" CallingConv? RETURN_ATTRIBUTES? function=TypeAndValue pList=ParameterList FUNCTION_ATTRIBUTES* "to"
		//
		//	to=TypeAndValue "unwind" unwind=TypeAndValue;
		public ParserRule getRule() { return rule; }

		//"invoke" CallingConv? RETURN_ATTRIBUTES? function=TypeAndValue pList=ParameterList FUNCTION_ATTRIBUTES* "to"
		//
		//to=TypeAndValue "unwind" unwind=TypeAndValue
		public Group getGroup() { return cGroup; }

		//"invoke"
		public Keyword getInvokeKeyword_0() { return cInvokeKeyword_0; }

		//CallingConv?
		public RuleCall getCallingConvParserRuleCall_1() { return cCallingConvParserRuleCall_1; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_2() { return cRETURN_ATTRIBUTESParserRuleCall_2; }

		//function=TypeAndValue
		public Assignment getFunctionAssignment_3() { return cFunctionAssignment_3; }

		//TypeAndValue
		public RuleCall getFunctionTypeAndValueParserRuleCall_3_0() { return cFunctionTypeAndValueParserRuleCall_3_0; }

		//pList=ParameterList
		public Assignment getPListAssignment_4() { return cPListAssignment_4; }

		//ParameterList
		public RuleCall getPListParameterListParserRuleCall_4_0() { return cPListParameterListParserRuleCall_4_0; }

		//FUNCTION_ATTRIBUTES*
		public RuleCall getFUNCTION_ATTRIBUTESParserRuleCall_5() { return cFUNCTION_ATTRIBUTESParserRuleCall_5; }

		//"to"
		public Keyword getToKeyword_6() { return cToKeyword_6; }

		//to=TypeAndValue
		public Assignment getToAssignment_7() { return cToAssignment_7; }

		//TypeAndValue
		public RuleCall getToTypeAndValueParserRuleCall_7_0() { return cToTypeAndValueParserRuleCall_7_0; }

		//"unwind"
		public Keyword getUnwindKeyword_8() { return cUnwindKeyword_8; }

		//unwind=TypeAndValue
		public Assignment getUnwindAssignment_9() { return cUnwindAssignment_9; }

		//TypeAndValue
		public RuleCall getUnwindTypeAndValueParserRuleCall_9_0() { return cUnwindTypeAndValueParserRuleCall_9_0; }
	}

	public class ResumeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Resume");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cResumeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cTypeAndValueParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		/// *
		//
		// * The 'resume' instruction is a terminator instruction that has no successors.
		//
		// * / Resume:
		//
		//	"resume" TypeAndValue;
		public ParserRule getRule() { return rule; }

		//"resume" TypeAndValue
		public Group getGroup() { return cGroup; }

		//"resume"
		public Keyword getResumeKeyword_0() { return cResumeKeyword_0; }

		//TypeAndValue
		public RuleCall getTypeAndValueParserRuleCall_1() { return cTypeAndValueParserRuleCall_1; }
	}

	public class UnreachableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unreachable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnreachableAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cUnreachableKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		/// *
		//
		// * The 'unreachable' instruction has no defined semantics. This instruction is used to inform the 
		//
		// * optimizer that a particular portion of the code is not reachable. This can be used to indicate 
		//
		// * that the code after a no-return function cannot be reached, and other facts.
		//
		// * / Unreachable:
		//
		//	{Unreachable} "unreachable";
		public ParserRule getRule() { return rule; }

		//{Unreachable} "unreachable"
		public Group getGroup() { return cGroup; }

		//{Unreachable}
		public Action getUnreachableAction_0() { return cUnreachableAction_0; }

		//"unreachable"
		public Keyword getUnreachableKeyword_1() { return cUnreachableKeyword_1; }
	}

	public class ReturnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Return");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cReturnAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cRetKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cVoidKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Keyword cDbgKeyword_0_3_1 = (Keyword)cGroup_0_3.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0_3_2 = (Keyword)cGroup_0_3.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_0_3_3 = (RuleCall)cGroup_0_3.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cRetKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueTypeAndValueParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Keyword cDbgKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_1_2_2 = (Keyword)cGroup_1_2.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_1_2_3 = (RuleCall)cGroup_1_2.eContents().get(3);
		
		/// *
		//
		// * The 'ret' instruction is used to return control flow (and optionally a value) 
		//
		// * from a function back to the caller.
		//
		// * 
		//
		// * There are two forms of the 'ret' instruction: one that returns a value and then 
		//
		// * causes control flow, and one that just causes control flow to occur.
		//
		// * / Return:
		//
		//	{Return} "ret" "void" ("," "!dbg" "!" INT)? | "ret" value=TypeAndValue ("," "!dbg" "!" INT)?;
		public ParserRule getRule() { return rule; }

		//{Return} "ret" "void" ("," "!dbg" "!" INT)? | "ret" value=TypeAndValue ("," "!dbg" "!" INT)?
		public Alternatives getAlternatives() { return cAlternatives; }

		//{Return} "ret" "void" ("," "!dbg" "!" INT)?
		public Group getGroup_0() { return cGroup_0; }

		//{Return}
		public Action getReturnAction_0_0() { return cReturnAction_0_0; }

		//"ret"
		public Keyword getRetKeyword_0_1() { return cRetKeyword_0_1; }

		//"void"
		public Keyword getVoidKeyword_0_2() { return cVoidKeyword_0_2; }

		//("," "!dbg" "!" INT)?
		public Group getGroup_0_3() { return cGroup_0_3; }

		//","
		public Keyword getCommaKeyword_0_3_0() { return cCommaKeyword_0_3_0; }

		//"!dbg"
		public Keyword getDbgKeyword_0_3_1() { return cDbgKeyword_0_3_1; }

		//"!"
		public Keyword getExclamationMarkKeyword_0_3_2() { return cExclamationMarkKeyword_0_3_2; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_3_3() { return cINTTerminalRuleCall_0_3_3; }

		//"ret" value=TypeAndValue ("," "!dbg" "!" INT)?
		public Group getGroup_1() { return cGroup_1; }

		//"ret"
		public Keyword getRetKeyword_1_0() { return cRetKeyword_1_0; }

		//value=TypeAndValue
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//TypeAndValue
		public RuleCall getValueTypeAndValueParserRuleCall_1_1_0() { return cValueTypeAndValueParserRuleCall_1_1_0; }

		//("," "!dbg" "!" INT)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//","
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }

		//"!dbg"
		public Keyword getDbgKeyword_1_2_1() { return cDbgKeyword_1_2_1; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_2_2() { return cExclamationMarkKeyword_1_2_2; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_2_3() { return cINTTerminalRuleCall_1_2_3; }
	}

	public class BranchElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Branch");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cBrKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cDestinationAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cDestinationTypeAndValueParserRuleCall_0_1_0 = (RuleCall)cDestinationAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cBrKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCondAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCondTypeAndValueParserRuleCall_1_1_0 = (RuleCall)cCondAssignment_1_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cLabelTrueAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cLabelTrueTypeAndValueParserRuleCall_1_3_0 = (RuleCall)cLabelTrueAssignment_1_3.eContents().get(0);
		private final Keyword cCommaKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cLabelFalseAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cLabelFalseTypeAndValueParserRuleCall_1_5_0 = (RuleCall)cLabelFalseAssignment_1_5.eContents().get(0);
		
		/// *
		//
		// * The 'br' instruction is used to cause control flow to transfer to a different basic block in 
		//
		// * the current function. There are two forms of this instruction, corresponding to a conditional 
		//
		// * branch and an unconditional branch.
		//
		// * / Branch:
		//
		//	"br" destination=TypeAndValue | "br" cond=TypeAndValue "," labelTrue=TypeAndValue "," labelFalse=TypeAndValue;
		public ParserRule getRule() { return rule; }

		//"br" destination=TypeAndValue | "br" cond=TypeAndValue "," labelTrue=TypeAndValue "," labelFalse=TypeAndValue
		public Alternatives getAlternatives() { return cAlternatives; }

		//"br" destination=TypeAndValue
		public Group getGroup_0() { return cGroup_0; }

		//"br"
		public Keyword getBrKeyword_0_0() { return cBrKeyword_0_0; }

		//destination=TypeAndValue
		public Assignment getDestinationAssignment_0_1() { return cDestinationAssignment_0_1; }

		//TypeAndValue
		public RuleCall getDestinationTypeAndValueParserRuleCall_0_1_0() { return cDestinationTypeAndValueParserRuleCall_0_1_0; }

		//"br" cond=TypeAndValue "," labelTrue=TypeAndValue "," labelFalse=TypeAndValue
		public Group getGroup_1() { return cGroup_1; }

		//"br"
		public Keyword getBrKeyword_1_0() { return cBrKeyword_1_0; }

		//cond=TypeAndValue
		public Assignment getCondAssignment_1_1() { return cCondAssignment_1_1; }

		//TypeAndValue
		public RuleCall getCondTypeAndValueParserRuleCall_1_1_0() { return cCondTypeAndValueParserRuleCall_1_1_0; }

		//","
		public Keyword getCommaKeyword_1_2() { return cCommaKeyword_1_2; }

		//labelTrue=TypeAndValue
		public Assignment getLabelTrueAssignment_1_3() { return cLabelTrueAssignment_1_3; }

		//TypeAndValue
		public RuleCall getLabelTrueTypeAndValueParserRuleCall_1_3_0() { return cLabelTrueTypeAndValueParserRuleCall_1_3_0; }

		//","
		public Keyword getCommaKeyword_1_4() { return cCommaKeyword_1_4; }

		//labelFalse=TypeAndValue
		public Assignment getLabelFalseAssignment_1_5() { return cLabelFalseAssignment_1_5; }

		//TypeAndValue
		public RuleCall getLabelFalseTypeAndValueParserRuleCall_1_5_0() { return cLabelFalseTypeAndValueParserRuleCall_1_5_0; }
	}

	public class FunctionBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMetaAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cMetaMetadataValueParserRuleCall_0_0 = (RuleCall)cMetaAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBlocksAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBlocksBasicBlockParserRuleCall_2_0 = (RuleCall)cBlocksAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cMetaAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMetaMetadataValueParserRuleCall_4_0 = (RuleCall)cMetaAssignment_4.eContents().get(0);
		
		/// * 
		//
		// * This rule is the start of the function body and has to be right after de 'define' of a function.
		//
		// * Every Functionbody contains at leaset one Basic Block. 
		//
		// * / FunctionBody:
		//
		//	meta+=MetadataValue* "{" blocks+=BasicBlock+ "}" meta+=MetadataValue*;
		public ParserRule getRule() { return rule; }

		//meta+=MetadataValue* "{" blocks+=BasicBlock+ "}" meta+=MetadataValue*
		public Group getGroup() { return cGroup; }

		//meta+=MetadataValue*
		public Assignment getMetaAssignment_0() { return cMetaAssignment_0; }

		//MetadataValue
		public RuleCall getMetaMetadataValueParserRuleCall_0_0() { return cMetaMetadataValueParserRuleCall_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//blocks+=BasicBlock+
		public Assignment getBlocksAssignment_2() { return cBlocksAssignment_2; }

		//BasicBlock
		public RuleCall getBlocksBasicBlockParserRuleCall_2_0() { return cBlocksBasicBlockParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }

		//meta+=MetadataValue*
		public Assignment getMetaAssignment_4() { return cMetaAssignment_4; }

		//MetadataValue
		public RuleCall getMetaMetadataValueParserRuleCall_4_0() { return cMetaMetadataValueParserRuleCall_4_0; }
	}

	public class BasicBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelDOTSTerminalRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final RuleCall cNOBRACKETTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cColonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cInstructionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInstructionsInstructionParserRuleCall_1_0 = (RuleCall)cInstructionsAssignment_1.eContents().get(0);
		private final Assignment cTerminatorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTerminatorRet_InstrParserRuleCall_2_0 = (RuleCall)cTerminatorAssignment_2.eContents().get(0);
		
		/// *
		//
		// * Every Basic Block is contained inside a Functionbody and has a label(eventually) and at least one instruction 
		//
		// * / BasicBlock:
		//
		//	(label=DOTS? NOBRACKET ":")? instructions+=Instruction* terminator=Ret_Instr;
		public ParserRule getRule() { return rule; }

		//(label=DOTS? NOBRACKET ":")? instructions+=Instruction* terminator=Ret_Instr
		public Group getGroup() { return cGroup; }

		//(label=DOTS? NOBRACKET ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=DOTS?
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//DOTS
		public RuleCall getLabelDOTSTerminalRuleCall_0_0_0() { return cLabelDOTSTerminalRuleCall_0_0_0; }

		//NOBRACKET
		public RuleCall getNOBRACKETTerminalRuleCall_0_1() { return cNOBRACKETTerminalRuleCall_0_1; }

		//":"
		public Keyword getColonKeyword_0_2() { return cColonKeyword_0_2; }

		//instructions+=Instruction*
		public Assignment getInstructionsAssignment_1() { return cInstructionsAssignment_1; }

		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_1_0() { return cInstructionsInstructionParserRuleCall_1_0; }

		//terminator=Ret_Instr
		public Assignment getTerminatorAssignment_2() { return cTerminatorAssignment_2; }

		//Ret_Instr
		public RuleCall getTerminatorRet_InstrParserRuleCall_2_0() { return cTerminatorRet_InstrParserRuleCall_2_0; }
	}

	public class Ret_InstrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Ret_Instr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cReturnParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBranchParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSwitchParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIndirectBranchParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cInvokeParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cResumeParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cUnreachableParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//Ret_Instr:
		//
		//	Return | Branch | Switch | IndirectBranch | Invoke | Resume | Unreachable;
		public ParserRule getRule() { return rule; }

		//Return | Branch | Switch | IndirectBranch | Invoke | Resume | Unreachable
		public Alternatives getAlternatives() { return cAlternatives; }

		//Return
		public RuleCall getReturnParserRuleCall_0() { return cReturnParserRuleCall_0; }

		//Branch
		public RuleCall getBranchParserRuleCall_1() { return cBranchParserRuleCall_1; }

		//Switch
		public RuleCall getSwitchParserRuleCall_2() { return cSwitchParserRuleCall_2; }

		//IndirectBranch
		public RuleCall getIndirectBranchParserRuleCall_3() { return cIndirectBranchParserRuleCall_3; }

		//Invoke
		public RuleCall getInvokeParserRuleCall_4() { return cInvokeParserRuleCall_4; }

		//Resume
		public RuleCall getResumeParserRuleCall_5() { return cResumeParserRuleCall_5; }

		//Unreachable
		public RuleCall getUnreachableParserRuleCall_6() { return cUnreachableParserRuleCall_6; }
	}

	public class VISIBILITYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VISIBILITY");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDefaultKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHiddenKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cProtectedKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		/// *
		//
		// * This is to summarize the possible visibilities
		//
		// * / VISIBILITY:
		//
		//	"default" | "hidden" | "protected";
		public ParserRule getRule() { return rule; }

		//"default" | "hidden" | "protected"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"default"
		public Keyword getDefaultKeyword_0() { return cDefaultKeyword_0; }

		//"hidden"
		public Keyword getHiddenKeyword_1() { return cHiddenKeyword_1; }

		//"protected"
		public Keyword getProtectedKeyword_2() { return cProtectedKeyword_2; }
	}

	public class LINKAGEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LINKAGE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPrivateKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLinker_privateKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLinker_private_weakKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cAvailable_externallyKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLinkonceKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cCommonKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cAppendingKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cExtern_weakKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLinkonce_odrKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cLinkonce_odr_auto_hideKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cDllimportKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cDllexportKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final RuleCall cALIAS_LINKAGEParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		
		/// *
		//
		// * This is to summarize the possible linkages
		//
		// * / LINKAGE:
		//
		//	"private" | "linker_private" | "linker_private_weak" | "available_externally" | "linkonce" | "common" | "appending" |
		//
		//	"extern_weak" | "linkonce_odr" | "linkonce_odr_auto_hide" | "dllimport" | "dllexport" | ALIAS_LINKAGE;
		public ParserRule getRule() { return rule; }

		//"private" | "linker_private" | "linker_private_weak" | "available_externally" | "linkonce" | "common" | "appending" |
		//
		//"extern_weak" | "linkonce_odr" | "linkonce_odr_auto_hide" | "dllimport" | "dllexport" | ALIAS_LINKAGE
		public Alternatives getAlternatives() { return cAlternatives; }

		//"private"
		public Keyword getPrivateKeyword_0() { return cPrivateKeyword_0; }

		//"linker_private"
		public Keyword getLinker_privateKeyword_1() { return cLinker_privateKeyword_1; }

		//"linker_private_weak"
		public Keyword getLinker_private_weakKeyword_2() { return cLinker_private_weakKeyword_2; }

		//"available_externally"
		public Keyword getAvailable_externallyKeyword_3() { return cAvailable_externallyKeyword_3; }

		//"linkonce"
		public Keyword getLinkonceKeyword_4() { return cLinkonceKeyword_4; }

		//"common"
		public Keyword getCommonKeyword_5() { return cCommonKeyword_5; }

		//"appending"
		public Keyword getAppendingKeyword_6() { return cAppendingKeyword_6; }

		//"extern_weak"
		public Keyword getExtern_weakKeyword_7() { return cExtern_weakKeyword_7; }

		//"linkonce_odr"
		public Keyword getLinkonce_odrKeyword_8() { return cLinkonce_odrKeyword_8; }

		//"linkonce_odr_auto_hide"
		public Keyword getLinkonce_odr_auto_hideKeyword_9() { return cLinkonce_odr_auto_hideKeyword_9; }

		//"dllimport"
		public Keyword getDllimportKeyword_10() { return cDllimportKeyword_10; }

		//"dllexport"
		public Keyword getDllexportKeyword_11() { return cDllexportKeyword_11; }

		//ALIAS_LINKAGE
		public RuleCall getALIAS_LINKAGEParserRuleCall_12() { return cALIAS_LINKAGEParserRuleCall_12; }
	}

	public class ALIAS_LINKAGEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ALIAS_LINKAGE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cExternalKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cInternalKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cWeakKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cWeak_odrKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		/// *
		//
		// * There are restriction on the Linkages of Aliasees. So...
		//
		// * / ALIAS_LINKAGE:
		//
		//	"external" | "internal" | "weak" | "weak_odr";
		public ParserRule getRule() { return rule; }

		//"external" | "internal" | "weak" | "weak_odr"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"external"
		public Keyword getExternalKeyword_0() { return cExternalKeyword_0; }

		//"internal"
		public Keyword getInternalKeyword_1() { return cInternalKeyword_1; }

		//"weak"
		public Keyword getWeakKeyword_2() { return cWeakKeyword_2; }

		//"weak_odr"
		public Keyword getWeak_odrKeyword_3() { return cWeak_odrKeyword_3; }
	}

	public class MetadataValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MetadataValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_0_1 = (RuleCall)cGroup_0_0.eContents().get(1);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Keyword cExclamationMarkLeftCurlyBracketKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final RuleCall cNOBRACKETTerminalRuleCall_0_1_1 = (RuleCall)cGroup_0_1.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_0_1_2 = (Keyword)cGroup_0_1.eContents().get(2);
		private final Group cGroup_0_2 = (Group)cAlternatives_0.eContents().get(2);
		private final Keyword cExclamationMarkKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final RuleCall cNOBRACKETTerminalRuleCall_0_2_1 = (RuleCall)cGroup_0_2.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Group cGroup_1_1_0 = (Group)cAlternatives_1_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1_0_0 = (Keyword)cGroup_1_1_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1_0_1 = (RuleCall)cGroup_1_1_0.eContents().get(1);
		private final Group cGroup_1_1_1 = (Group)cAlternatives_1_1.eContents().get(1);
		private final Keyword cExclamationMarkLeftCurlyBracketKeyword_1_1_1_0 = (Keyword)cGroup_1_1_1.eContents().get(0);
		private final RuleCall cNOBRACKETTerminalRuleCall_1_1_1_1 = (RuleCall)cGroup_1_1_1.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_1_1_1_2 = (Keyword)cGroup_1_1_1.eContents().get(2);
		private final Group cGroup_1_1_2 = (Group)cAlternatives_1_1.eContents().get(2);
		private final Keyword cExclamationMarkKeyword_1_1_2_0 = (Keyword)cGroup_1_1_2.eContents().get(0);
		private final RuleCall cNOBRACKETTerminalRuleCall_1_1_2_1 = (RuleCall)cGroup_1_1_2.eContents().get(1);
		private final Group cGroup_1_1_3 = (Group)cAlternatives_1_1.eContents().get(3);
		private final Keyword cMetadataKeyword_1_1_3_0 = (Keyword)cGroup_1_1_3.eContents().get(0);
		private final Group cGroup_1_1_3_1 = (Group)cGroup_1_1_3.eContents().get(1);
		private final Alternatives cAlternatives_1_1_3_1_0 = (Alternatives)cGroup_1_1_3_1.eContents().get(0);
		private final Group cGroup_1_1_3_1_0_0 = (Group)cAlternatives_1_1_3_1_0.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1_3_1_0_0_0 = (Keyword)cGroup_1_1_3_1_0_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1_3_1_0_0_1 = (Keyword)cGroup_1_1_3_1_0_0.eContents().get(1);
		private final Keyword cExclamationMarkLeftCurlyBracketKeyword_1_1_3_1_0_1 = (Keyword)cAlternatives_1_1_3_1_0.eContents().get(1);
		private final Keyword cMetadataKeyword_1_1_3_1_1 = (Keyword)cGroup_1_1_3_1.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_1_1_3_1_2 = (Keyword)cGroup_1_1_3_1.eContents().get(2);
		private final RuleCall cSTRINGTerminalRuleCall_1_1_3_1_3 = (RuleCall)cGroup_1_1_3_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_1_3_1_4 = (Keyword)cGroup_1_1_3_1.eContents().get(4);
		private final Alternatives cAlternatives_1_1_3_1_5 = (Alternatives)cGroup_1_1_3_1.eContents().get(5);
		private final Group cGroup_1_1_3_1_5_0 = (Group)cAlternatives_1_1_3_1_5.eContents().get(0);
		private final Keyword cMetadataKeyword_1_1_3_1_5_0_0 = (Keyword)cGroup_1_1_3_1_5_0.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1_3_1_5_0_1 = (Keyword)cGroup_1_1_3_1_5_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_1_3_1_5_0_2 = (RuleCall)cGroup_1_1_3_1_5_0.eContents().get(2);
		private final RuleCall cBASIC_TYPEParserRuleCall_1_1_3_1_5_1 = (RuleCall)cAlternatives_1_1_3_1_5.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_1_1_3_1_6 = (Keyword)cGroup_1_1_3_1.eContents().get(6);
		
		/// *
		//
		// * This rule is needed to support Metadata
		//
		// * Example:
		//
		// *  ; Named metadata
		//
		// *	!1 = metadata !{i32 42}
		//
		// *	!foo = !{!1, null} 
		//
		// *  !1 = metadata !{metadata !"omnipotent char", metadata !2}
		//
		// * / MetadataValue:
		//
		//	("!" INT | "!{" NOBRACKET "}" | "!" NOBRACKET) ("=" ("!" INT | "!{" NOBRACKET "}" | "!" NOBRACKET | "metadata" (("!"
		//
		//	"{" | "!{") "metadata" "!" STRING "," ("metadata" "!" INT | BASIC_TYPE) "}")?))?;
		public ParserRule getRule() { return rule; }

		//("!" INT | "!{" NOBRACKET "}" | "!" NOBRACKET) ("=" ("!" INT | "!{" NOBRACKET "}" | "!" NOBRACKET | "metadata" (("!" "{"
		//
		//| "!{") "metadata" "!" STRING "," ("metadata" "!" INT | BASIC_TYPE) "}")?))?
		public Group getGroup() { return cGroup; }

		//"!" INT | "!{" NOBRACKET "}" | "!" NOBRACKET
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"!" INT
		public Group getGroup_0_0() { return cGroup_0_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_0_0_0() { return cExclamationMarkKeyword_0_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_0_1() { return cINTTerminalRuleCall_0_0_1; }

		//"!{" NOBRACKET "}"
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"!{"
		public Keyword getExclamationMarkLeftCurlyBracketKeyword_0_1_0() { return cExclamationMarkLeftCurlyBracketKeyword_0_1_0; }

		//NOBRACKET
		public RuleCall getNOBRACKETTerminalRuleCall_0_1_1() { return cNOBRACKETTerminalRuleCall_0_1_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_0_1_2() { return cRightCurlyBracketKeyword_0_1_2; }

		//"!" NOBRACKET
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"!"
		public Keyword getExclamationMarkKeyword_0_2_0() { return cExclamationMarkKeyword_0_2_0; }

		//NOBRACKET
		public RuleCall getNOBRACKETTerminalRuleCall_0_2_1() { return cNOBRACKETTerminalRuleCall_0_2_1; }

		//("=" ("!" INT | "!{" NOBRACKET "}" | "!" NOBRACKET | "metadata" (("!" "{" | "!{") "metadata" "!" STRING "," ("metadata"
		//
		//"!" INT | BASIC_TYPE) "}")?))?
		public Group getGroup_1() { return cGroup_1; }

		//"="
		public Keyword getEqualsSignKeyword_1_0() { return cEqualsSignKeyword_1_0; }

		//"!" INT | "!{" NOBRACKET "}" | "!" NOBRACKET | "metadata" (("!" "{" | "!{") "metadata" "!" STRING "," ("metadata" "!"
		//
		//INT | BASIC_TYPE) "}")?
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"!" INT
		public Group getGroup_1_1_0() { return cGroup_1_1_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_1_0_0() { return cExclamationMarkKeyword_1_1_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1_0_1() { return cINTTerminalRuleCall_1_1_0_1; }

		//"!{" NOBRACKET "}"
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//"!{"
		public Keyword getExclamationMarkLeftCurlyBracketKeyword_1_1_1_0() { return cExclamationMarkLeftCurlyBracketKeyword_1_1_1_0; }

		//NOBRACKET
		public RuleCall getNOBRACKETTerminalRuleCall_1_1_1_1() { return cNOBRACKETTerminalRuleCall_1_1_1_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_1_1_2() { return cRightCurlyBracketKeyword_1_1_1_2; }

		//"!" NOBRACKET
		public Group getGroup_1_1_2() { return cGroup_1_1_2; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_1_2_0() { return cExclamationMarkKeyword_1_1_2_0; }

		//NOBRACKET
		public RuleCall getNOBRACKETTerminalRuleCall_1_1_2_1() { return cNOBRACKETTerminalRuleCall_1_1_2_1; }

		//"metadata" (("!" "{" | "!{") "metadata" "!" STRING "," ("metadata" "!" INT | BASIC_TYPE) "}")?
		public Group getGroup_1_1_3() { return cGroup_1_1_3; }

		//"metadata"
		public Keyword getMetadataKeyword_1_1_3_0() { return cMetadataKeyword_1_1_3_0; }

		//(("!" "{" | "!{") "metadata" "!" STRING "," ("metadata" "!" INT | BASIC_TYPE) "}")?
		public Group getGroup_1_1_3_1() { return cGroup_1_1_3_1; }

		//"!" "{" | "!{"
		public Alternatives getAlternatives_1_1_3_1_0() { return cAlternatives_1_1_3_1_0; }

		//"!" "{"
		public Group getGroup_1_1_3_1_0_0() { return cGroup_1_1_3_1_0_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_1_3_1_0_0_0() { return cExclamationMarkKeyword_1_1_3_1_0_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_1_3_1_0_0_1() { return cLeftCurlyBracketKeyword_1_1_3_1_0_0_1; }

		//"!{"
		public Keyword getExclamationMarkLeftCurlyBracketKeyword_1_1_3_1_0_1() { return cExclamationMarkLeftCurlyBracketKeyword_1_1_3_1_0_1; }

		//"metadata"
		public Keyword getMetadataKeyword_1_1_3_1_1() { return cMetadataKeyword_1_1_3_1_1; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_1_3_1_2() { return cExclamationMarkKeyword_1_1_3_1_2; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1_1_3_1_3() { return cSTRINGTerminalRuleCall_1_1_3_1_3; }

		//","
		public Keyword getCommaKeyword_1_1_3_1_4() { return cCommaKeyword_1_1_3_1_4; }

		//"metadata" "!" INT | BASIC_TYPE
		public Alternatives getAlternatives_1_1_3_1_5() { return cAlternatives_1_1_3_1_5; }

		//"metadata" "!" INT
		public Group getGroup_1_1_3_1_5_0() { return cGroup_1_1_3_1_5_0; }

		//"metadata"
		public Keyword getMetadataKeyword_1_1_3_1_5_0_0() { return cMetadataKeyword_1_1_3_1_5_0_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_1_3_1_5_0_1() { return cExclamationMarkKeyword_1_1_3_1_5_0_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1_3_1_5_0_2() { return cINTTerminalRuleCall_1_1_3_1_5_0_2; }

		//BASIC_TYPE
		public RuleCall getBASIC_TYPEParserRuleCall_1_1_3_1_5_1() { return cBASIC_TYPEParserRuleCall_1_1_3_1_5_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_1_3_1_6() { return cRightCurlyBracketKeyword_1_1_3_1_6; }
	}

	public class ALIGNMENTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ALIGNMENT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAlignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		/// *
		//
		// * This rule is to define the alignment
		//
		// * / ALIGNMENT:
		//
		//	"align" //must be a power of 2
		//
		//	INT;
		public ParserRule getRule() { return rule; }

		//"align" //must be a power of 2
		//
		//INT
		public Group getGroup() { return cGroup; }

		//"align"
		public Keyword getAlignKeyword_0() { return cAlignKeyword_0; }

		////must be a power of 2
		//
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	
	
	private LLVMElements pLLVM;
	private TerminalRule tDOTS;
	private TerminalRule tINTEGER;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tVAR_TYPE;
	private TerminalRule tBRACKETS;
	private TerminalRule tVAR_ID;
	private TerminalRule tPREFIX_CHAR;
	private TerminalRule tNOBRACKET;
	private TerminalRule tPOINT;
	private AbstractElementElements pAbstractElement;
	private TopLevelEntityElements pTopLevelEntity;
	private MainLevelEntityElements pMainLevelEntity;
	private FunctionHeaderElements pFunctionHeader;
	private ParameterListElements pParameterList;
	private TypeListElements pTypeList;
	private AggregateElements pAggregate;
	private LocalVarElements pLocalVar;
	private AliasElements pAlias;
	private TypeElements pType;
	private TypeAndValueElements pTypeAndValue;
	private StructTypeElements pStructType;
	private B_TYPEElements pB_TYPE;
	private BASIC_TYPEElements pBASIC_TYPE;
	private F_POINTElements pF_POINT;
	private GetElementPtrElements pGetElementPtr;
	private ExtractValueElements pExtractValue;
	private InsertValueElements pInsertValue;
	private FenceElements pFence;
	private ATOMIC_ORDERINGElements pATOMIC_ORDERING;
	private CmpXchgElements pCmpXchg;
	private AtomicRMWElements pAtomicRMW;
	private BIN_OPElements pBIN_OP;
	private LoadElements pLoad;
	private StoreElements pStore;
	private CallElements pCall;
	private RETURN_ATTRIBUTESElements pRETURN_ATTRIBUTES;
	private AllocElements pAlloc;
	private CallingConvElements pCallingConv;
	private FUNCTION_ATTRIBUTESElements pFUNCTION_ATTRIBUTES;
	private PHIElements pPHI;
	private ValuePairElements pValuePair;
	private LandingPadElements pLandingPad;
	private ClauseElements pClause;
	private SelectElements pSelect;
	private VA_ArgElements pVA_Arg;
	private ExtractElementElements pExtractElement;
	private InsertElementElements pInsertElement;
	private ShuffleVectorElements pShuffleVector;
	private CastElements pCast;
	private CAST_TYPEElements pCAST_TYPE;
	private CompareElements pCompare;
	private I_PREDICATESElements pI_PREDICATES;
	private F_PREDICATESElements pF_PREDICATES;
	private ARITHMETIC_OPElements pARITHMETIC_OP;
	private LOGICAL_OPElements pLOGICAL_OP;
	private InstructionElements pInstruction;
	private IndirectBranchElements pIndirectBranch;
	private LabelListElements pLabelList;
	private SwitchElements pSwitch;
	private JumpTableElements pJumpTable;
	private InvokeElements pInvoke;
	private ResumeElements pResume;
	private UnreachableElements pUnreachable;
	private ReturnElements pReturn;
	private BranchElements pBranch;
	private FunctionBodyElements pFunctionBody;
	private BasicBlockElements pBasicBlock;
	private Ret_InstrElements pRet_Instr;
	private VISIBILITYElements pVISIBILITY;
	private LINKAGEElements pLINKAGE;
	private ALIAS_LINKAGEElements pALIAS_LINKAGE;
	private MetadataValueElements pMetadataValue;
	private ALIGNMENTElements pALIGNMENT;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public LLVMGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.upb.llvm_parser.LLVM".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/// *
	//
	// * This Grammer is used to parse a llvm document.
	//
	// * The llvm project itself is located at http://llvm.org
	//
	// * For a language introduction see: http://llvm.org/docs/LangRef.html
	//
	// * A list of guides can be found on: http://llvm.org/docs/userguides.html
	//
	// * / LLVM:
	//
	//	elements+=AbstractElement*;
	public LLVMElements getLLVMAccess() {
		return (pLLVM != null) ? pLLVM : (pLLVM = new LLVMElements());
	}
	
	public ParserRule getLLVMRule() {
		return getLLVMAccess().getRule();
	}

	//terminal DOTS:
	//
	//	"."*;
	public TerminalRule getDOTSRule() {
		return (tDOTS != null) ? tDOTS : (tDOTS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOTS"));
	} 

	/// *
	//
	// * Integer defintion: iN(*)*
	//
	// * Examples:
	//
	// * 	i32  			- 32 bit Integer
	//
	// *  i1   			- Single bit Integer
	//
	// *  i32 (i32*) *	- A pointer to a function that takes an i32*, returning an i32.
	//
	// * / terminal INTEGER:
	//
	//	"i" "0".."9"+ "*"*;
	public TerminalRule getINTEGERRule() {
		return (tINTEGER != null) ? tINTEGER : (tINTEGER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INTEGER"));
	} 

	/// *
	//
	// * Comments are delimited with a ';' and go until the end of line.
	//
	// * / terminal SL_COMMENT:
	//
	//	";" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	/// *
	//
	// * Initial Variable Definition
	//
	// * Every Variable starts with either '%' for local or '@' for global
	//
	// * the regualar expression for this identifiers is [%@][a-zA-Z$._][a-zA-Z$._0-9]*
	//
	// * 
	//
	// * Examples:
	//
	// *  %foo
	//
	// *  (%Stack.Node).Node.a.very.long.identifier 
	//
	// *  @_44bar.your.choice
	//
	// * / terminal VAR_TYPE:
	//
	//	(PREFIX_CHAR VAR_ID | "(" VAR_TYPE ")" "*"*) ("." (BRACKETS | VAR_ID))*;
	public TerminalRule getVAR_TYPERule() {
		return (tVAR_TYPE != null) ? tVAR_TYPE : (tVAR_TYPE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "VAR_TYPE"));
	} 

	////	(((('%' | '@')'.'*) (NOBRACKET | '(' NOBRACKET ')' | INT) '*'*) | '('+ (('%' | '@')'.'*) (NOBRACKET | '(' NOBRACKET ')' | '%'
	//
	////	INT) '*'* ')'+ '*'*);
	//
	//terminal BRACKETS:
	//
	//	"(" VAR_ID ")" "*"*;
	public TerminalRule getBRACKETSRule() {
		return (tBRACKETS != null) ? tBRACKETS : (tBRACKETS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BRACKETS"));
	} 

	//terminal VAR_ID:
	//
	//	("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")* "*"*;
	public TerminalRule getVAR_IDRule() {
		return (tVAR_ID != null) ? tVAR_ID : (tVAR_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "VAR_ID"));
	} 

	//terminal PREFIX_CHAR:
	//
	//	("%" | "@") "."?;
	public TerminalRule getPREFIX_CHARRule() {
		return (tPREFIX_CHAR != null) ? tPREFIX_CHAR : (tPREFIX_CHAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PREFIX_CHAR"));
	} 

	/// *
	//
	// * Inner Identifier Rule (no Brackets allowed)
	//
	// * / terminal NOBRACKET:
	//
	//	("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")* POINT?;
	public TerminalRule getNOBRACKETRule() {
		return (tNOBRACKET != null) ? tNOBRACKET : (tNOBRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NOBRACKET"));
	} 

	/// *
	//
	// * This rule is responsible for the dot
	//
	// * / terminal POINT:
	//
	//	"." (NOBRACKET | "(" NOBRACKET ")");
	public TerminalRule getPOINTRule() {
		return (tPOINT != null) ? tPOINT : (tPOINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "POINT"));
	} 

	/// *
	//
	// * An Abstract Element is either a TopLevelEntity, used for the predefinitions of the llvm-code
	//
	// * or a MainLevelEntity, which are basically functiondefinitions. 
	//
	// * / AbstractElement:
	//
	//	TopLevelEntity SL_COMMENT? | MainLevelEntity SL_COMMENT?;
	public AbstractElementElements getAbstractElementAccess() {
		return (pAbstractElement != null) ? pAbstractElement : (pAbstractElement = new AbstractElementElements());
	}
	
	public ParserRule getAbstractElementRule() {
		return getAbstractElementAccess().getRule();
	}

	/// *
	//
	// * Predefinitions of the llvm-code
	//
	// * / TopLevelEntity:
	//
	//	"module" "asm" module=STRING | "target" ("datalayout" | "triple") "=" target=STRING | "deplibs" "=" "[" libs+=STRING
	//
	//	("," libs+=STRING)* "]";
	public TopLevelEntityElements getTopLevelEntityAccess() {
		return (pTopLevelEntity != null) ? pTopLevelEntity : (pTopLevelEntity = new TopLevelEntityElements());
	}
	
	public ParserRule getTopLevelEntityRule() {
		return getTopLevelEntityAccess().getRule();
	}

	/// *
	//
	// * This rule is used to devide the Function Definitions form the Variable Definitions.
	//
	// * / MainLevelEntity:
	//
	//	FunctionHeader | LocalVar;
	public MainLevelEntityElements getMainLevelEntityAccess() {
		return (pMainLevelEntity != null) ? pMainLevelEntity : (pMainLevelEntity = new MainLevelEntityElements());
	}
	
	public ParserRule getMainLevelEntityRule() {
		return getMainLevelEntityAccess().getRule();
	}

	/// *
	//
	// * A Function Header has to be defined or declared.
	//
	// * If a function is declared, there will be no function body, and also the parameterlist needn't to be defined
	//
	// * Example: 
	//
	// *  declare i32 @__gxx_personality_v0(...)
	//
	// * If a function is defined, there are multiple optional parameters such as visibility or return attributes.
	//
	// * Example:
	//
	// *  define linkonce_odr void @_ZN4NodeC1Ev(%class.Node* %this) unnamed_addr align 2 { ... }
	//
	// * / FunctionHeader:
	//
	//	"define" LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=Type name=VAR_TYPE pl=ParameterList
	//
	//	"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT? body=FunctionBody | "declare" LINKAGE?
	//
	//	VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=Type name=VAR_TYPE (tList=TypeList | "(...)") "unnamed_addr"?
	//
	//	FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT?;
	public FunctionHeaderElements getFunctionHeaderAccess() {
		return (pFunctionHeader != null) ? pFunctionHeader : (pFunctionHeader = new FunctionHeaderElements());
	}
	
	public ParserRule getFunctionHeaderRule() {
		return getFunctionHeaderAccess().getRule();
	}

	/// *
	//
	// * This rule creates a Parameterlist and saves also the TypeAndValue to each parameter 
	//
	// * / ParameterList:
	//
	//	"(" (((VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type) ("," ((VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? Type))*)? ")";
	public ParameterListElements getParameterListAccess() {
		return (pParameterList != null) ? pParameterList : (pParameterList = new ParameterListElements());
	}
	
	public ParserRule getParameterListRule() {
		return getParameterListAccess().getRule();
	}

	/// *
	//
	// * If a function is declared, the parameterlist has to be set empty or contain a List of Types.
	//
	// * / TypeList:
	//
	//	{TypeList} "(" (types+=Type ("," types+=Type)*)? ")";
	public TypeListElements getTypeListAccess() {
		return (pTypeList != null) ? pTypeList : (pTypeList = new TypeListElements());
	}
	
	public ParserRule getTypeListRule() {
		return getTypeListAccess().getRule();
	}

	/// *
	//
	// * An Aggregate is a tuple of types enclosed by curly brackets
	//
	// * / Aggregate:
	//
	//	"{" agg+=Type ("," agg+=Type) "}";
	public AggregateElements getAggregateAccess() {
		return (pAggregate != null) ? pAggregate : (pAggregate = new AggregateElements());
	}
	
	public ParserRule getAggregateRule() {
		return getAggregateAccess().getRule();
	}

	/// *
	//
	// * A Local Variable definition needs a name, followed by an equalsign and either an Instruction, an Alias or a Type  
	//
	// * / LocalVar:
	//
	//	name=Type "=" ("type" type=Type | instr=Instruction | alias=Alias);
	public LocalVarElements getLocalVarAccess() {
		return (pLocalVar != null) ? pLocalVar : (pLocalVar = new LocalVarElements());
	}
	
	public ParserRule getLocalVarRule() {
		return getLocalVarAccess().getRule();
	}

	/// *
	//
	// * Aliases act as "second name" for the aliasee value (which can be either function, 
	//
	// * global variable, another alias or bitcast of global value). 
	//
	// * Aliases may have an optional linkage type, and an optional visibility style
	//
	// * / Alias:
	//
	//	"alias" ALIAS_LINKAGE? VISIBILITY? type=TypeAndValue aliasee=Type;
	public AliasElements getAliasAccess() {
		return (pAlias != null) ? pAlias : (pAlias = new AliasElements());
	}
	
	public ParserRule getAliasRule() {
		return getAliasAccess().getRule();
	}

	/// *
	//
	// * Types..
	//
	// * A Type is a type.
	//
	// * There are different types. Primitive Types, Struct Types, or own VaraiableTypes.
	//
	// * This rule is used to summarize them
	//
	// * / Type:
	//
	//	(StructType | VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES?;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	/// *
	//
	// * This rule is used to bind a Type to a value.
	//
	// * It is used for example on parameterlists, on instructions etc.
	//
	// * / TypeAndValue:
	//
	//	type=(VAR_TYPE | B_TYPE) RETURN_ATTRIBUTES? value=Type | aggregate=Aggregate value=Type;
	public TypeAndValueElements getTypeAndValueAccess() {
		return (pTypeAndValue != null) ? pTypeAndValue : (pTypeAndValue = new TypeAndValueElements());
	}
	
	public ParserRule getTypeAndValueRule() {
		return getTypeAndValueAccess().getRule();
	}

	/// *
	//
	// * This rule specified Stuctures
	//
	// * / StructType:
	//
	//	"{" ((VAR_TYPE | B_TYPE) ("," (VAR_TYPE | B_TYPE))*)? "}" | "<" "{" ((VAR_TYPE | B_TYPE) ("," (VAR_TYPE | B_TYPE))*)?
	//
	//	"}" ">";
	public StructTypeElements getStructTypeAccess() {
		return (pStructType != null) ? pStructType : (pStructType = new StructTypeElements());
	}
	
	public ParserRule getStructTypeRule() {
		return getStructTypeAccess().getRule();
	}

	/// *
	//
	// * To summerize all BASIC_TYPEs inside one Rule.
	//
	// * / B_TYPE:
	//
	//	INTEGER | F_POINT | BASIC_TYPE | INT;
	public B_TYPEElements getB_TYPEAccess() {
		return (pB_TYPE != null) ? pB_TYPE : (pB_TYPE = new B_TYPEElements());
	}
	
	public ParserRule getB_TYPERule() {
		return getB_TYPEAccess().getRule();
	}

	/// *
	//
	// * To distinguish the types here only Basic Types
	//
	// * / BASIC_TYPE:
	//
	//	"void" | "null" | "label" | "undef" | "true" | "false";
	public BASIC_TYPEElements getBASIC_TYPEAccess() {
		return (pBASIC_TYPE != null) ? pBASIC_TYPE : (pBASIC_TYPE = new BASIC_TYPEElements());
	}
	
	public ParserRule getBASIC_TYPERule() {
		return getBASIC_TYPEAccess().getRule();
	}

	/// *
	//
	// * To distinguish the types here only Floating Types
	//
	// * / F_POINT:
	//
	//	"half" | "float" | "double" | "x86_fp80" | "fp128" | "ppc_fp128";
	public F_POINTElements getF_POINTAccess() {
		return (pF_POINT != null) ? pF_POINT : (pF_POINT = new F_POINTElements());
	}
	
	public ParserRule getF_POINTRule() {
		return getF_POINTAccess().getRule();
	}

	/// *
	//
	// * The 'getelementptr' instruction is used to get the address of a subelement of an aggregate data structure. 
	//
	// * It performs address calculation only and does not access memory.
	//
	// * / GetElementPtr:
	//
	//	"getelementptr" "inbounds"? pointer+=TypeAndValue ("," params+=TypeAndValue)*;
	public GetElementPtrElements getGetElementPtrAccess() {
		return (pGetElementPtr != null) ? pGetElementPtr : (pGetElementPtr = new GetElementPtrElements());
	}
	
	public ParserRule getGetElementPtrRule() {
		return getGetElementPtrAccess().getRule();
	}

	/// *
	//
	// * The 'extractvalue' instruction extracts the value of a member field from an aggregate value.
	//
	// * / ExtractValue:
	//
	//	"extractvalue" aggregate=Aggregate type=Type ("," index+=INT)+;
	public ExtractValueElements getExtractValueAccess() {
		return (pExtractValue != null) ? pExtractValue : (pExtractValue = new ExtractValueElements());
	}
	
	public ParserRule getExtractValueRule() {
		return getExtractValueAccess().getRule();
	}

	/// *
	//
	// * The 'insertvalue' instruction inserts a value into a member field in an aggregate value.
	//
	// * / InsertValue:
	//
	//	"insertvalue" aggregate=Aggregate type=Type "," value=TypeAndValue ("," index+=INT)+;
	public InsertValueElements getInsertValueAccess() {
		return (pInsertValue != null) ? pInsertValue : (pInsertValue = new InsertValueElements());
	}
	
	public ParserRule getInsertValueRule() {
		return getInsertValueAccess().getRule();
	}

	/// *
	//
	// * The 'fence' instruction is used to introduce happens-before edges between operations.
	//
	// * / Fence:
	//
	//	"fence" "singlethread"? ordering=ATOMIC_ORDERING;
	public FenceElements getFenceAccess() {
		return (pFence != null) ? pFence : (pFence = new FenceElements());
	}
	
	public ParserRule getFenceRule() {
		return getFenceAccess().getRule();
	}

	/// *
	//
	// * This is only a summarize of the possible atomic orderings
	//
	// * / ATOMIC_ORDERING:
	//
	//	"unordered" | "monotonic" | "aquire" | "release" | "acq_rel" | "seq_cst";
	public ATOMIC_ORDERINGElements getATOMIC_ORDERINGAccess() {
		return (pATOMIC_ORDERING != null) ? pATOMIC_ORDERING : (pATOMIC_ORDERING = new ATOMIC_ORDERINGElements());
	}
	
	public ParserRule getATOMIC_ORDERINGRule() {
		return getATOMIC_ORDERINGAccess().getRule();
	}

	/// *
	//
	// * The 'cmpxchg' instruction is used to atomically modify memory. It loads a value in memory and compares it to 
	//
	// * a given value. If they are equal, it stores a new value into the memory.
	//
	// * / CmpXchg:
	//
	//	"cmpxchg" "volatile"? adress=TypeAndValue "," compare_val=TypeAndValue "," new_val=TypeAndValue "singlethread"?
	//
	//	ordering=ATOMIC_ORDERING;
	public CmpXchgElements getCmpXchgAccess() {
		return (pCmpXchg != null) ? pCmpXchg : (pCmpXchg = new CmpXchgElements());
	}
	
	public ParserRule getCmpXchgRule() {
		return getCmpXchgAccess().getRule();
	}

	/// *
	//
	// * The 'atomicrmw' instruction is used to atomically modify memory.
	//
	// * / AtomicRMW:
	//
	//	"atomicrmw" "volatile"? BIN_OP adress=TypeAndValue "," value=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING;
	public AtomicRMWElements getAtomicRMWAccess() {
		return (pAtomicRMW != null) ? pAtomicRMW : (pAtomicRMW = new AtomicRMWElements());
	}
	
	public ParserRule getAtomicRMWRule() {
		return getAtomicRMWAccess().getRule();
	}

	/// *
	//
	// * This is only to summarize the different Binary Operations
	//
	// * / BIN_OP:
	//
	//	"xchg" | "add" | "sub" | "and" | "nand" | "or" | "xor" | "max" | "min" | "umax" | "umin";
	public BIN_OPElements getBIN_OPAccess() {
		return (pBIN_OP != null) ? pBIN_OP : (pBIN_OP = new BIN_OPElements());
	}
	
	public ParserRule getBIN_OPRule() {
		return getBIN_OPAccess().getRule();
	}

	/// *
	//
	// * The 'load' instruction is used to read from memory.
	//
	// * / Load:
	//
	//	"load" "volatile"? adress=TypeAndValue ("," (ALIGNMENT | MetadataValue+))* | "load" "atomic" "volatile"?
	//
	//	adress=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING ("," "align" index=INT)?;
	public LoadElements getLoadAccess() {
		return (pLoad != null) ? pLoad : (pLoad = new LoadElements());
	}
	
	public ParserRule getLoadRule() {
		return getLoadAccess().getRule();
	}

	/// *
	//
	// * The 'store' instruction is used to write to memory.
	//
	// * / Store:
	//
	//	"store" "volatile"? value=TypeAndValue "," adress=TypeAndValue ("," (ALIGNMENT | MetadataValue+))* | "store" "atomic"
	//
	//	"volatile"? value=TypeAndValue "," adress=TypeAndValue "singlethread"? ordering=ATOMIC_ORDERING ("," "align"
	//
	//	index=INT)?;
	public StoreElements getStoreAccess() {
		return (pStore != null) ? pStore : (pStore = new StoreElements());
	}
	
	public ParserRule getStoreRule() {
		return getStoreAccess().getRule();
	}

	/// *
	//
	// * The 'call' instruction represents a simple function call.
	//
	// * / Call:
	//
	//	"tail"? "call" CallingConv? RETURN_ATTRIBUTES? pointer=TypeAndValue pList=ParameterList FUNCTION_ATTRIBUTES*;
	public CallElements getCallAccess() {
		return (pCall != null) ? pCall : (pCall = new CallElements());
	}
	
	public ParserRule getCallRule() {
		return getCallAccess().getRule();
	}

	/// *
	//
	// * This is to summarize the possible return attributes
	//
	// * / RETURN_ATTRIBUTES:
	//
	//	"zeroext" | "signext" | "inreg" | "byval" | "sret" | "noalias" | "nocapture" | "nest";
	public RETURN_ATTRIBUTESElements getRETURN_ATTRIBUTESAccess() {
		return (pRETURN_ATTRIBUTES != null) ? pRETURN_ATTRIBUTES : (pRETURN_ATTRIBUTES = new RETURN_ATTRIBUTESElements());
	}
	
	public ParserRule getRETURN_ATTRIBUTESRule() {
		return getRETURN_ATTRIBUTESAccess().getRule();
	}

	//Alloc:
	//
	//	"alloca" type=Type ("," numElements=TypeAndValue)? ("," ALIGNMENT)?;
	public AllocElements getAllocAccess() {
		return (pAlloc != null) ? pAlloc : (pAlloc = new AllocElements());
	}
	
	public ParserRule getAllocRule() {
		return getAllocAccess().getRule();
	}

	/// *
	//
	// * This is to summarize the possible Calling Conventions
	//
	// * / CallingConv:
	//
	//	"ccc" | "fastcc" | "coldcc" | "x86_stdcallcc" | "x86_fastcallcc" | "x86_thiscallcc" | "arm_apcscc" | "arm_aapcscc" |
	//
	//	"arm_aapcs_vfpcc" | "msp430_intrcc" | "ptx_kernel" | "ptx_device" | "spir_func" | "spir_kernel" | "cc" "<" INT ">"
	//
	//	INT;
	public CallingConvElements getCallingConvAccess() {
		return (pCallingConv != null) ? pCallingConv : (pCallingConv = new CallingConvElements());
	}
	
	public ParserRule getCallingConvRule() {
		return getCallingConvAccess().getRule();
	}

	/// *
	//
	// * This is to summarize the possible function attributes
	//
	// * / FUNCTION_ATTRIBUTES:
	//
	//	"address_safety" | "alignstack" "(" "<" INT ">" ")" | "alwaysinline" | "nonlazybind" | "inlinehint" | "naked" |
	//
	//	"noimplicitfloat" | "noinline" | "noredzone" | "noreturn" | "nounwind" | "optsize" | "readnone" | "readonly" |
	//
	//	"returns_twice" | "ssp" | "sspreq" | "uwtable";
	public FUNCTION_ATTRIBUTESElements getFUNCTION_ATTRIBUTESAccess() {
		return (pFUNCTION_ATTRIBUTES != null) ? pFUNCTION_ATTRIBUTES : (pFUNCTION_ATTRIBUTES = new FUNCTION_ATTRIBUTESElements());
	}
	
	public ParserRule getFUNCTION_ATTRIBUTESRule() {
		return getFUNCTION_ATTRIBUTESAccess().getRule();
	}

	/// *
	//
	// * The 'phi' instruction is used to implement the  node in the SSA graph representing the function.
	//
	// * / PHI:
	//
	//	"phi" Type "[" values+=ValuePair "]" ("," "[" values+=ValuePair "]")*;
	public PHIElements getPHIAccess() {
		return (pPHI != null) ? pPHI : (pPHI = new PHIElements());
	}
	
	public ParserRule getPHIRule() {
		return getPHIAccess().getRule();
	}

	/// *
	//
	// * This rule is used to bring in more clarity in some instructions
	//
	// * / ValuePair:
	//
	//	value1=Type "," value2=Type;
	public ValuePairElements getValuePairAccess() {
		return (pValuePair != null) ? pValuePair : (pValuePair = new ValuePairElements());
	}
	
	public ParserRule getValuePairRule() {
		return getValuePairAccess().getRule();
	}

	/// *
	//
	// * The 'landingpad' instruction is used by LLVM's exception handling system to specify that a basic 
	//
	// * block is a landing pad  one where the exception lands, and corresponds to the code found in the 
	//
	// * catch portion of a try/catch sequence. It defines values supplied by the personality function (pers_fn)
	//
	// * upon re-entry to the function. The resultval has the type resultty.
	//
	// * / LandingPad:
	//
	//	"landingpad" type=Type "personality" personality=TypeAndValue ("cleanup" clause+=Clause* | clause+=Clause+) |
	//
	//	"landingpad" type=Type "personality" personalitytype=Type personalityfunction=CAST_TYPE "(" value=Type "(...)*"
	//
	//	VAR_TYPE "to" castto=Type ")" ("cleanup" clause+=Clause* | clause+=Clause+);
	public LandingPadElements getLandingPadAccess() {
		return (pLandingPad != null) ? pLandingPad : (pLandingPad = new LandingPadElements());
	}
	
	public ParserRule getLandingPadRule() {
		return getLandingPadAccess().getRule();
	}

	/// *
	//
	// * A clause begins with the clause type  catch or filter  and contains the global variable representing
	//
	// * the "type" that may be caught or filtered respectively. Unlike the catch clause, the filter clause takes
	//
	// * an array constant as its argument. Use "[0 x i8**] undef" for a filter which cannot throw. The 'landingpad'
	//
	// * instruction must contain at least one clause or the cleanup flag.
	//
	// * / Clause:
	//
	//	"catch" TypeAndValue | "filter" filter+=TypeAndValue ("," filter+=TypeAndValue)*;
	public ClauseElements getClauseAccess() {
		return (pClause != null) ? pClause : (pClause = new ClauseElements());
	}
	
	public ParserRule getClauseRule() {
		return getClauseAccess().getRule();
	}

	/// *
	//
	// * The 'select' instruction is used to choose one value based on a condition, without branching.
	//
	// * / Select:
	//
	//	"select" condition=TypeAndValue "," val1=TypeAndValue "," val2=TypeAndValue;
	public SelectElements getSelectAccess() {
		return (pSelect != null) ? pSelect : (pSelect = new SelectElements());
	}
	
	public ParserRule getSelectRule() {
		return getSelectAccess().getRule();
	}

	/// *
	//
	// * The 'va_arg' instruction is used to access arguments passed through the "variable argument" area of a 
	//
	// * function call. It is used to implement the va_arg macro in C.
	//
	// * / VA_Arg:
	//
	//	"va_arg" list=TypeAndValue "," argType=Type;
	public VA_ArgElements getVA_ArgAccess() {
		return (pVA_Arg != null) ? pVA_Arg : (pVA_Arg = new VA_ArgElements());
	}
	
	public ParserRule getVA_ArgRule() {
		return getVA_ArgAccess().getRule();
	}

	/// *
	//
	// * The 'extractelement' instruction extracts a single scalar element from a vector at a specified index.
	//
	// * / ExtractElement:
	//
	//	"extractelement" vector=TypeAndValue "," index=TypeAndValue;
	public ExtractElementElements getExtractElementAccess() {
		return (pExtractElement != null) ? pExtractElement : (pExtractElement = new ExtractElementElements());
	}
	
	public ParserRule getExtractElementRule() {
		return getExtractElementAccess().getRule();
	}

	/// *
	//
	// * The 'insertelement' instruction inserts a scalar element into a vector at a specified index.
	//
	// * / InsertElement:
	//
	//	"insertelement" vector=TypeAndValue "," scalar=TypeAndValue "," index=TypeAndValue;
	public InsertElementElements getInsertElementAccess() {
		return (pInsertElement != null) ? pInsertElement : (pInsertElement = new InsertElementElements());
	}
	
	public ParserRule getInsertElementRule() {
		return getInsertElementAccess().getRule();
	}

	/// *
	//
	// * The 'shufflevector' instruction constructs a permutation of elements from two input vectors, 
	//
	// * returning a vector with the same element type as the input and length that is the same as the shuffle mask.
	//
	// * / ShuffleVector:
	//
	//	"shufflevector" vector1=TypeAndValue "," vector2=TypeAndValue "," mask=TypeAndValue;
	public ShuffleVectorElements getShuffleVectorAccess() {
		return (pShuffleVector != null) ? pShuffleVector : (pShuffleVector = new ShuffleVectorElements());
	}
	
	public ParserRule getShuffleVectorRule() {
		return getShuffleVectorAccess().getRule();
	}

	/// *
	//
	// * This rule is to provide a typecast. Nothing special
	//
	// * Example
	//
	// *  %X = trunc i32 257 to i8
	//
	// *  %Z = fptosi float 1.04E+17 to i8
	//
	// * / Cast:
	//
	//	CAST_TYPE value=TypeAndValue "to" castto=Type;
	public CastElements getCastAccess() {
		return (pCast != null) ? pCast : (pCast = new CastElements());
	}
	
	public ParserRule getCastRule() {
		return getCastAccess().getRule();
	}

	/// *
	//
	// * The instructions in this category are the conversion instructions (casting) which
	//
	// * all take a single operand and a type. They perform various bit conversions on the operand.
	//
	// * / CAST_TYPE:
	//
	//	"trunc" | "zext" | "sext" | "fptrunc" | "fpext" | "fptoui" | "fptosi" | "uitofp" | "sitofp" | "ptrtoint" | "inttoptr"
	//
	//	| "bitcast";
	public CAST_TYPEElements getCAST_TYPEAccess() {
		return (pCAST_TYPE != null) ? pCAST_TYPE : (pCAST_TYPE = new CAST_TYPEElements());
	}
	
	public ParserRule getCAST_TYPERule() {
		return getCAST_TYPEAccess().getRule();
	}

	/// *
	//
	// * The 'icmp' instruction returns a boolean value or a vector of boolean values based on comparison of 
	//
	// * 		its two integer, integer vector, pointer, or pointer vector operands.
	//
	// * The 'fcmp' instruction returns a boolean value or vector of boolean values based on comparison of its operands.
	//
	// * / Compare:
	//
	//	"icmp" I_PREDICATES Type ValuePair | "fcmp" F_PREDICATES Type ValuePair;
	public CompareElements getCompareAccess() {
		return (pCompare != null) ? pCompare : (pCompare = new CompareElements());
	}
	
	public ParserRule getCompareRule() {
		return getCompareAccess().getRule();
	}

	/// *
	//
	// * This is to summarize the possible Integer Predicates
	//
	// * / I_PREDICATES:
	//
	//	"eq" | "ne" | "ugt" | "uge" | "ult" | "ule" | "sgt" | "sge" | "slt" | "sle";
	public I_PREDICATESElements getI_PREDICATESAccess() {
		return (pI_PREDICATES != null) ? pI_PREDICATES : (pI_PREDICATES = new I_PREDICATESElements());
	}
	
	public ParserRule getI_PREDICATESRule() {
		return getI_PREDICATESAccess().getRule();
	}

	/// *
	//
	// * This is to summarize the possible Floating Predicates
	//
	// * / F_PREDICATES:
	//
	//	"false" | "oeq" | "ogt" | "oge" | "olt" | "ole" | "one" | "ord" | "ueq" | "ugt" | "uge" | "ult" | "ule" | "une" |
	//
	//	"uno" | "true";
	public F_PREDICATESElements getF_PREDICATESAccess() {
		return (pF_PREDICATES != null) ? pF_PREDICATES : (pF_PREDICATES = new F_PREDICATESElements());
	}
	
	public ParserRule getF_PREDICATESRule() {
		return getF_PREDICATESAccess().getRule();
	}

	/// *
	//
	// * This is to summarize the possible Arithmetic Operations
	//
	// * / ARITHMETIC_OP:
	//
	//	("add" | "fadd" | "sub" | "fsub" | "mul" | "fmul" | "udiv" | "sdiv" | "fdiv" | "urem" | "srem" | "frem") Type
	//
	//	ValuePair;
	public ARITHMETIC_OPElements getARITHMETIC_OPAccess() {
		return (pARITHMETIC_OP != null) ? pARITHMETIC_OP : (pARITHMETIC_OP = new ARITHMETIC_OPElements());
	}
	
	public ParserRule getARITHMETIC_OPRule() {
		return getARITHMETIC_OPAccess().getRule();
	}

	/// *
	//
	// * This is to summarize the possible Logical Operations
	//
	// * / LOGICAL_OP:
	//
	//	("shl" | "lshr" | "ashr" | "and" | "or" | "xor") Type ValuePair;
	public LOGICAL_OPElements getLOGICAL_OPAccess() {
		return (pLOGICAL_OP != null) ? pLOGICAL_OP : (pLOGICAL_OP = new LOGICAL_OPElements());
	}
	
	public ParserRule getLOGICAL_OPRule() {
		return getLOGICAL_OPAccess().getRule();
	}

	/// *
	//
	// * This is only to summarize all possible Instructions
	//
	// * / Instruction:
	//
	//	"volatile"? Load | "volatile"? Store | Fence | GetElementPtr | LOGICAL_OP | ARITHMETIC_OP | Compare | Cast |
	//
	//	ShuffleVector | InsertElement | ExtractElement | InsertValue | ExtractValue | Alloc | CmpXchg | AtomicRMW | PHI |
	//
	//	Select | Call | VA_Arg | LandingPad | LocalVar;
	public InstructionElements getInstructionAccess() {
		return (pInstruction != null) ? pInstruction : (pInstruction = new InstructionElements());
	}
	
	public ParserRule getInstructionRule() {
		return getInstructionAccess().getRule();
	}

	/// *
	//
	// * The 'indirectbr' instruction implements an indirect branch to a label within the current function, whose 
	//
	// * address is specified by "address". Address must be derived from a blockaddress constant.
	//
	// * / IndirectBranch:
	//
	//	"indirectbr" adress=TypeAndValue "," "[" lList=LabelList? "]";
	public IndirectBranchElements getIndirectBranchAccess() {
		return (pIndirectBranch != null) ? pIndirectBranch : (pIndirectBranch = new IndirectBranchElements());
	}
	
	public ParserRule getIndirectBranchRule() {
		return getIndirectBranchAccess().getRule();
	}

	/// *
	//
	// * The Indirect Branch instruction needs a List of labels to jump to. 
	//
	// * This List is created here an contains Pairs of Types and Values
	//
	// * / LabelList:
	//
	//	labels+=TypeAndValue+;
	public LabelListElements getLabelListAccess() {
		return (pLabelList != null) ? pLabelList : (pLabelList = new LabelListElements());
	}
	
	public ParserRule getLabelListRule() {
		return getLabelListAccess().getRule();
	}

	/// *
	//
	// * The 'switch' instruction is used to transfer control flow to one of several different places. It is a generalization of 
	//
	// * the 'br' instruction, allowing a branch to occur to one of many possible destinations.
	//
	// * / Switch:
	//
	//	"switch" value=TypeAndValue "," default=TypeAndValue "[" jTable=JumpTable? "]";
	public SwitchElements getSwitchAccess() {
		return (pSwitch != null) ? pSwitch : (pSwitch = new SwitchElements());
	}
	
	public ParserRule getSwitchRule() {
		return getSwitchAccess().getRule();
	}

	/// *
	//
	// * The Switch instruction needs a list of values and destination, that will be jumped in case of value occures
	//
	// * / JumpTable:
	//
	//	(values+=TypeAndValue "," destinations+=TypeAndValue)+;
	public JumpTableElements getJumpTableAccess() {
		return (pJumpTable != null) ? pJumpTable : (pJumpTable = new JumpTableElements());
	}
	
	public ParserRule getJumpTableRule() {
		return getJumpTableAccess().getRule();
	}

	/// *
	//
	// * The 'invoke' instruction causes control to transfer to a specified function, with the possibility of 
	//
	// * control flow transfer to either the 'normal' label or the 'exception' label. If the callee function 
	//
	// * returns with the "ret" instruction, control flow will return to the "normal" label. If the callee 
	//
	// * (or any indirect callees) returns via the "resume" instruction or other exception handling mechanism, 
	//
	// * control is interrupted and continued at the dynamically nearest "exception" label.
	//
	// * 
	//
	// * The 'exception' label is a landing pad for the exception. As such, 'exception' label is required to
	//
	// *  have the "landingpad" instruction, which contains the information about the behavior of the program 
	//
	// * after unwinding happens, as its first non-PHI instruction. The restrictions on the "landingpad" 
	//
	// * instruction's tightly couples it to the "invoke" instruction, so that the important information contained 
	//
	// * within the "landingpad" instruction can't be lost through normal code motion.
	//
	// * / Invoke:
	//
	//	"invoke" CallingConv? RETURN_ATTRIBUTES? function=TypeAndValue pList=ParameterList FUNCTION_ATTRIBUTES* "to"
	//
	//	to=TypeAndValue "unwind" unwind=TypeAndValue;
	public InvokeElements getInvokeAccess() {
		return (pInvoke != null) ? pInvoke : (pInvoke = new InvokeElements());
	}
	
	public ParserRule getInvokeRule() {
		return getInvokeAccess().getRule();
	}

	/// *
	//
	// * The 'resume' instruction is a terminator instruction that has no successors.
	//
	// * / Resume:
	//
	//	"resume" TypeAndValue;
	public ResumeElements getResumeAccess() {
		return (pResume != null) ? pResume : (pResume = new ResumeElements());
	}
	
	public ParserRule getResumeRule() {
		return getResumeAccess().getRule();
	}

	/// *
	//
	// * The 'unreachable' instruction has no defined semantics. This instruction is used to inform the 
	//
	// * optimizer that a particular portion of the code is not reachable. This can be used to indicate 
	//
	// * that the code after a no-return function cannot be reached, and other facts.
	//
	// * / Unreachable:
	//
	//	{Unreachable} "unreachable";
	public UnreachableElements getUnreachableAccess() {
		return (pUnreachable != null) ? pUnreachable : (pUnreachable = new UnreachableElements());
	}
	
	public ParserRule getUnreachableRule() {
		return getUnreachableAccess().getRule();
	}

	/// *
	//
	// * The 'ret' instruction is used to return control flow (and optionally a value) 
	//
	// * from a function back to the caller.
	//
	// * 
	//
	// * There are two forms of the 'ret' instruction: one that returns a value and then 
	//
	// * causes control flow, and one that just causes control flow to occur.
	//
	// * / Return:
	//
	//	{Return} "ret" "void" ("," "!dbg" "!" INT)? | "ret" value=TypeAndValue ("," "!dbg" "!" INT)?;
	public ReturnElements getReturnAccess() {
		return (pReturn != null) ? pReturn : (pReturn = new ReturnElements());
	}
	
	public ParserRule getReturnRule() {
		return getReturnAccess().getRule();
	}

	/// *
	//
	// * The 'br' instruction is used to cause control flow to transfer to a different basic block in 
	//
	// * the current function. There are two forms of this instruction, corresponding to a conditional 
	//
	// * branch and an unconditional branch.
	//
	// * / Branch:
	//
	//	"br" destination=TypeAndValue | "br" cond=TypeAndValue "," labelTrue=TypeAndValue "," labelFalse=TypeAndValue;
	public BranchElements getBranchAccess() {
		return (pBranch != null) ? pBranch : (pBranch = new BranchElements());
	}
	
	public ParserRule getBranchRule() {
		return getBranchAccess().getRule();
	}

	/// * 
	//
	// * This rule is the start of the function body and has to be right after de 'define' of a function.
	//
	// * Every Functionbody contains at leaset one Basic Block. 
	//
	// * / FunctionBody:
	//
	//	meta+=MetadataValue* "{" blocks+=BasicBlock+ "}" meta+=MetadataValue*;
	public FunctionBodyElements getFunctionBodyAccess() {
		return (pFunctionBody != null) ? pFunctionBody : (pFunctionBody = new FunctionBodyElements());
	}
	
	public ParserRule getFunctionBodyRule() {
		return getFunctionBodyAccess().getRule();
	}

	/// *
	//
	// * Every Basic Block is contained inside a Functionbody and has a label(eventually) and at least one instruction 
	//
	// * / BasicBlock:
	//
	//	(label=DOTS? NOBRACKET ":")? instructions+=Instruction* terminator=Ret_Instr;
	public BasicBlockElements getBasicBlockAccess() {
		return (pBasicBlock != null) ? pBasicBlock : (pBasicBlock = new BasicBlockElements());
	}
	
	public ParserRule getBasicBlockRule() {
		return getBasicBlockAccess().getRule();
	}

	//Ret_Instr:
	//
	//	Return | Branch | Switch | IndirectBranch | Invoke | Resume | Unreachable;
	public Ret_InstrElements getRet_InstrAccess() {
		return (pRet_Instr != null) ? pRet_Instr : (pRet_Instr = new Ret_InstrElements());
	}
	
	public ParserRule getRet_InstrRule() {
		return getRet_InstrAccess().getRule();
	}

	/// *
	//
	// * This is to summarize the possible visibilities
	//
	// * / VISIBILITY:
	//
	//	"default" | "hidden" | "protected";
	public VISIBILITYElements getVISIBILITYAccess() {
		return (pVISIBILITY != null) ? pVISIBILITY : (pVISIBILITY = new VISIBILITYElements());
	}
	
	public ParserRule getVISIBILITYRule() {
		return getVISIBILITYAccess().getRule();
	}

	/// *
	//
	// * This is to summarize the possible linkages
	//
	// * / LINKAGE:
	//
	//	"private" | "linker_private" | "linker_private_weak" | "available_externally" | "linkonce" | "common" | "appending" |
	//
	//	"extern_weak" | "linkonce_odr" | "linkonce_odr_auto_hide" | "dllimport" | "dllexport" | ALIAS_LINKAGE;
	public LINKAGEElements getLINKAGEAccess() {
		return (pLINKAGE != null) ? pLINKAGE : (pLINKAGE = new LINKAGEElements());
	}
	
	public ParserRule getLINKAGERule() {
		return getLINKAGEAccess().getRule();
	}

	/// *
	//
	// * There are restriction on the Linkages of Aliasees. So...
	//
	// * / ALIAS_LINKAGE:
	//
	//	"external" | "internal" | "weak" | "weak_odr";
	public ALIAS_LINKAGEElements getALIAS_LINKAGEAccess() {
		return (pALIAS_LINKAGE != null) ? pALIAS_LINKAGE : (pALIAS_LINKAGE = new ALIAS_LINKAGEElements());
	}
	
	public ParserRule getALIAS_LINKAGERule() {
		return getALIAS_LINKAGEAccess().getRule();
	}

	/// *
	//
	// * This rule is needed to support Metadata
	//
	// * Example:
	//
	// *  ; Named metadata
	//
	// *	!1 = metadata !{i32 42}
	//
	// *	!foo = !{!1, null} 
	//
	// *  !1 = metadata !{metadata !"omnipotent char", metadata !2}
	//
	// * / MetadataValue:
	//
	//	("!" INT | "!{" NOBRACKET "}" | "!" NOBRACKET) ("=" ("!" INT | "!{" NOBRACKET "}" | "!" NOBRACKET | "metadata" (("!"
	//
	//	"{" | "!{") "metadata" "!" STRING "," ("metadata" "!" INT | BASIC_TYPE) "}")?))?;
	public MetadataValueElements getMetadataValueAccess() {
		return (pMetadataValue != null) ? pMetadataValue : (pMetadataValue = new MetadataValueElements());
	}
	
	public ParserRule getMetadataValueRule() {
		return getMetadataValueAccess().getRule();
	}

	/// *
	//
	// * This rule is to define the alignment
	//
	// * / ALIGNMENT:
	//
	//	"align" //must be a power of 2
	//
	//	INT;
	public ALIGNMENTElements getALIGNMENTAccess() {
		return (pALIGNMENT != null) ? pALIGNMENT : (pALIGNMENT = new ALIGNMENTElements());
	}
	
	public ParserRule getALIGNMENTRule() {
		return getALIGNMENTAccess().getRule();
	}

	//terminal ID:
	//
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal WS:
	//
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
