[comment encoding = UTF-8 /]
[module GeneratePromelaModel('http://www.upb.de/lina/cfg/controlflow', 'http://www.upb.de/lina/cfg/gendata', 'http://www.upb.de/llvm_parser/llvm', 'http://www.eclipse.org/emf/2002/Ecore')]
[import de::upb::lina::transformations::promela::PromelaCommon/]

[template public generateModel(genData : GeneratorData, fileName: String) post (trim())]   
[comment @main/]
[file ( fileName  , false, 'UTF-8')]
[generateProgramIndependentDefinitions()/]
[genGlobalVars(genData)/]

[generateGetElementPtrIfNeeded(genData)/]
[generateMemoryAllocation(genData)/]
[generateCasIfNeeded(genData)/]

[generateFunctions(genData)/]

[generateProcessStubsAndInitialisations(genData)/]
[/file]
[/template]

[template public generateFunctions (genData : GeneratorData) ]
[for (cfg: ControlFlowDiagram | genData.cfgs)]
[genFunctionHead(cfg, genData)/]
[genLocalVarDeclarations(cfg, genData)/]
[handleStartLocation(genData, cfg)/]
[for (loc: ControlFlowLocation | cfg.locations)]
[handleLocation(loc, genData)/]
[/for][handleEndLocation(genData, cfg)/]
}

[/for]
[/template]

[template public handleStartLocation(genData:GeneratorData, cfg: ControlFlowDiagram)] 
[cfg.start.label.substring(1, 1)/]Start: goto [cfg.start.label/]; 
[/template]

[template public handleEndLocation(genData:GeneratorData, cfg: ControlFlowDiagram)] 
[cfg.start.label.substring(1, 1)/]End: skip; 
[/template]

[template public handleLocation(loc: ControlFlowLocation, genData: GeneratorData)]
[if (loc.outgoing->size() = 1)][handleDeterministicLocation(loc, genData)/][elseif (loc.outgoing->size() > 1)][handleNonDeterministicLocation(loc, genData)/][/if]
[/template]

[template public handleDeterministicLocation(loc: ControlFlowLocation, genData: GeneratorData)]
[loc.label/]: [transformTransition(loc.outgoing->first(), genData)/][generateGoTo(loc.outgoing->first(), genData)/]
[/template]

[template public handleNonDeterministicLocation(loc: ControlFlowLocation, genData: GeneratorData)]
[loc.label/]: 
	if 
	[for (t : Transition | loc.outgoing)] 
	:: [generateCondition(t, genData)/][transformTransition(t, genData)/][generateGoTo(t, genData)/]
   	[/for]
	fi;
[/template]


[template public generateGoTo(t: Transition, genData: GeneratorData)][if (t.target.outgoing->size() > 0)][genPhiAssignments(t, genData)/]goto [t.target.label/]; [else]goto [t.target.label.substring(1, 1)/]End;[/if][/template]


[template public transformTransition(t: EarlyReadTransition, genData: GeneratorData)]
[getVariableForAddress(t.instruction.oclAsType(Load).result, t, genData).newName/] = [t.assignmentExpression/]; 
[/template]

[template public transformTransition(t: WriteDefChainTransition, genData: GeneratorData)]
[if (t.copyAddress.oclIsUndefined())][else][getVariableForAddress(t.copyAddress, t, genData).newName/] = [valueToString(t.instruction.oclAsType(Store).targetAddress.value, t, genData)/]; [/if][if (t.copyValue.oclIsUndefined())][else][getVariableForAddress(t.copyValue, t, genData).newName/] = [valueToString(t.instruction.oclAsType(Store).value.value, t, genData)/]; [/if] 
[/template]

[template public transformTransition(t: Transition, genData: GeneratorData)]
[genInstruction(t.instruction, t, genData)/]
[/template]

[template public transformTransition(t: FlushTransition, genData: GeneratorData)]
memory['['/][valueToString(t.flushedEntry.address.value, t, genData)/][']'/] = [valueToString(t.flushedEntry.values->first().value, t, genData)/]; 
[/template]

[template public genInstruction(e : Branch, t: Transition, genData: GeneratorData)][/template]

[template public genInstruction(e : CmpXchg, t: Transition, genData : GeneratorData)]
cas([valueToString(e.address.value, t, genData)/], [valueToString(e.value.value, t, genData)/], [valueToString(e.newValue.value, t, genData)/], [getVariableForAddress(e.result, t, genData).newName/]); 
[/template]

[template public genInstruction(e : AtomicRMW, t: Transition, genData : GeneratorData)]
atomic{[getVariableForAddress(e.result, t, genData).newName/] = [valueToString(e.address.value, t, genData)/]; memory['['/][valueToString(e.address.value, t, genData)/][']'/] = [e.genAtomicRMWOperation(t, genData)/];} 
[/template]

[query public genAtomicRMWOperation(c : AtomicRMW, t: Transition, genData: GeneratorData) : String = 
if 	c.operation.equalsIgnoreCase('xchg') then
	valueToString(c.argument.value, t, genData)
else if c.operation.equalsIgnoreCase('add') then
	'memory[' + valueToString(c.address.value, t, genData) + '] + ' + valueToString(c.argument.value, t, genData)
else if c.operation.equalsIgnoreCase('sub') then
	'memory[' + valueToString(c.address.value, t, genData) + '] - ' + valueToString(c.argument.value, t, genData)
else if c.operation.equalsIgnoreCase('and') then
	'memory[' + valueToString(c.address.value, t, genData) + '] & ' + valueToString(c.argument.value, t, genData)
else if c.operation.equalsIgnoreCase('nand') then
	'!(memory[' +  valueToString(c.address.value, t, genData) + '] & ' + valueToString(c.argument.value, t, genData) + ')'
else if c.operation.equalsIgnoreCase('or') then
	'(memory[' +  valueToString(c.address.value, t, genData) + '] | ' + valueToString(c.argument.value, t, genData) + ')'
else if c.operation.equalsIgnoreCase('xor') then
	'(memory[' +  valueToString(c.address.value, t, genData) + '] ^ ' + valueToString(c.argument.value, t, genData) + ')'
else if c.operation.equalsIgnoreCase('max') then
	'memory[' + valueToString(c.address.value, t, genData) + '] > ' + valueToString(c.argument.value, t, genData) + ' -> ' + 'memory[' + valueToString(c.address.value, t, genData) + '] : ' + valueToString(c.argument.value, t, genData)
else if c.operation.equalsIgnoreCase('min') then
	'memory[' + valueToString(c.address.value, t, genData) + '] < ' + valueToString(c.argument.value, t, genData) + ' -> ' + 'memory[' + valueToString(c.address.value, t, genData) + '] : ' + valueToString(c.argument.value, t, genData)
else if c.operation.equalsIgnoreCase('umax') then
	'memory[' + valueToString(c.address.value, t, genData) + '] > ' + valueToString(c.argument.value, t, genData) + ' -> ' + 'memory[' + valueToString(c.address.value, t, genData) + '] : ' + valueToString(c.argument.value, t, genData)
else if c.operation.equalsIgnoreCase('umin') then
	'memory[' + valueToString(c.address.value, t, genData) + '] < ' + valueToString(c.argument.value, t, genData) + ' -> ' + 'memory[' + valueToString(c.address.value, t, genData) + '] : ' + valueToString(c.argument.value, t, genData)
else
	'ERROR: unknown operation'
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
/]

[template public genInstruction(e : Load,  t: Transition, genData : GeneratorData)]
[getVariableForAddress(e.result, t, genData).newName/] = memory['['/][valueToString(e.address.value, t, genData)/][']'/]; 
[/template]

[template public genInstruction(e : Store,  t: Transition, genData : GeneratorData)][/template]


[template public generateCondition(t : GuardedTransition, genData: GeneratorData)]
[t.condition/] -> 
[/template]

[template public generateCondition(t : Transition, genData: GeneratorData)][/template]


[query public getTransitionGuard(t : Transition, genData: GeneratorData) : ConstraintMapping = 
genData.constraints->any(cm | cm.transition = t) 
/]

[query public genCondition(t : Transition, genData: GeneratorData) : String = 
if 'true'.equalsIgnoreCase(getTransitionGuard(t, genData).condition) then
	'' 
else 
	getTransitionGuard(t, genData).condition + ' -> '
endif 
/]


[comment basic stuff /]
[template public generateProgramIndependentDefinitions(c: OclAny)]
#define MEM_SIZE 15	//size of memory
#define null 0
#define I32  1
#define PTR 1

short memory['['/]MEM_SIZE[']'/];
short memUse = 1; 	//shows to the next free cell in memory


[/template]

[template public generateProcessStubsAndInitialisations(c: OclAny, genData: GeneratorData)]

//Stubs
proctype process1(){
	//TODO: empty stub
}

proctype process2(){
	//TODO: empty stub
}


init{
atomic{
	//initialize global variables or allocate memory space here, if necessary
	[genGlobalVariableAllocation(genData)/]

	run process1();
	run process2();
	}
}
[/template]

[template public generateGetElementPtrIfNeeded(genData: GeneratorData)]
[if (not genData.transformationSpecificKeys->any(s | s.equalsIgnoreCase('getelementptr')).oclIsUndefined())]
//pointer computation 
inline getelementptr(type, instance, offset, targetRegister)
{
	atomic{
	//simplified version of what llvm does.
	//we don't need the type as long as we assume our memory to hold only values/pointers etc of equal length. 
	//In this case, the offset directly correspond to adding it to instance address. 
	assert(offset <= type); //offset shouldn't be greater than the type range
	targetRegister = instance + offset;
	}
}
[/if]
[/template]

[template public generateMemoryAllocation(any: OclAny)]
//memory allocation
inline alloca(type, targetRegister)
{
	atomic{
	targetRegister = memUse;
	memUse = memUse + type;
	assert(memUse < MEM_SIZE);
	}
}
[/template]

[template public generateCasIfNeeded(genData: GeneratorData)]
[if (not genData.transformationSpecificKeys->any(s | s.equalsIgnoreCase('cas')).oclIsUndefined())]
//atomic compare and swap instruction 
//Note, LLVM returns a tuple (i32, i1), the value read and a success bit.
//Sometimes the follow up code uses the succes bit but usually the read value. 
//Adjust CAS semantics, if necessary.
inline cas(adr, old, new, result)
{
	atomic{
	//in LLVM result is usually a tuple (memory['['/]adr[']'/], successFlag)
	//we assume it to be just a loaded value
	result = memory['['/]adr[']'/];
	if 	:: memory['['/]adr[']'/] == old -> memory['['/]adr[']'/] = new; 
		:: else -> skip;
	fi;
	}
}
[/if]
[/template]
