/*
* generated by Xtext
*/

package de.upb.lina.lll.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class ExpressionsGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		//
		// * Once, I wrote this in the context of story diagram meta-models. As it is no longer supported there,
		//
		// * I am going to maintain it within this project. 
		//
		// * Oleg 
		//
		// * / // Boolean Logic Layer    ------------------------------------------------
		//
		//Expression:
		//
		//	LExpression | AExpression;
		public ParserRule getRule() { return rule; }

		//LExpression | AExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//LExpression
		public RuleCall getLExpressionParserRuleCall_0() { return cLExpressionParserRuleCall_0; }

		//AExpression
		public RuleCall getAExpressionParserRuleCall_1() { return cAExpressionParserRuleCall_1; }
	}

	public class LExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LExpression");
		private final RuleCall cEquivalentParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LExpression:
		//
		//	Equivalent;
		public ParserRule getRule() { return rule; }

		//Equivalent
		public RuleCall getEquivalentParserRuleCall() { return cEquivalentParserRuleCall; }
	}

	public class EquivalentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Equivalent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEquivalentLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEquivKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEquivalentParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Equivalent returns LExpression:
		//
		//	Implication ({Equivalent.left=current} "equiv" right=Equivalent)?;
		public ParserRule getRule() { return rule; }

		//Implication ({Equivalent.left=current} "equiv" right=Equivalent)?
		public Group getGroup() { return cGroup; }

		//Implication
		public RuleCall getImplicationParserRuleCall_0() { return cImplicationParserRuleCall_0; }

		//({Equivalent.left=current} "equiv" right=Equivalent)?
		public Group getGroup_1() { return cGroup_1; }

		//{Equivalent.left=current}
		public Action getEquivalentLeftAction_1_0() { return cEquivalentLeftAction_1_0; }

		//"equiv"
		public Keyword getEquivKeyword_1_1() { return cEquivKeyword_1_1; }

		//right=Equivalent
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Equivalent
		public RuleCall getRightEquivalentParserRuleCall_1_2_0() { return cRightEquivalentParserRuleCall_1_2_0; }
	}

	public class ImplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Implication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDisjunctionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImplyLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cImplyKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightImplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Implication returns LExpression:
		//
		//	Disjunction ({Imply.left=current} "imply" right=Implication)?;
		public ParserRule getRule() { return rule; }

		//Disjunction ({Imply.left=current} "imply" right=Implication)?
		public Group getGroup() { return cGroup; }

		//Disjunction
		public RuleCall getDisjunctionParserRuleCall_0() { return cDisjunctionParserRuleCall_0; }

		//({Imply.left=current} "imply" right=Implication)?
		public Group getGroup_1() { return cGroup_1; }

		//{Imply.left=current}
		public Action getImplyLeftAction_1_0() { return cImplyLeftAction_1_0; }

		//"imply"
		public Keyword getImplyKeyword_1_1() { return cImplyKeyword_1_1; }

		//right=Implication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Implication
		public RuleCall getRightImplicationParserRuleCall_1_2_0() { return cRightImplicationParserRuleCall_1_2_0; }
	}

	public class DisjunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Disjunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConjunctionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cOrLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cOrKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cXorLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cXorKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightDisjunctionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Disjunction returns LExpression:
		//
		//	Conjunction (({Or.left=current} "or" | {Xor.left=current} "xor") right=Disjunction)?;
		public ParserRule getRule() { return rule; }

		//Conjunction (({Or.left=current} "or" | {Xor.left=current} "xor") right=Disjunction)?
		public Group getGroup() { return cGroup; }

		//Conjunction
		public RuleCall getConjunctionParserRuleCall_0() { return cConjunctionParserRuleCall_0; }

		//(({Or.left=current} "or" | {Xor.left=current} "xor") right=Disjunction)?
		public Group getGroup_1() { return cGroup_1; }

		//{Or.left=current} "or" | {Xor.left=current} "xor"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Or.left=current} "or"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Or.left=current}
		public Action getOrLeftAction_1_0_0_0() { return cOrLeftAction_1_0_0_0; }

		//"or"
		public Keyword getOrKeyword_1_0_0_1() { return cOrKeyword_1_0_0_1; }

		//{Xor.left=current} "xor"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Xor.left=current}
		public Action getXorLeftAction_1_0_1_0() { return cXorLeftAction_1_0_1_0; }

		//"xor"
		public Keyword getXorKeyword_1_0_1_1() { return cXorKeyword_1_0_1_1; }

		//right=Disjunction
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Disjunction
		public RuleCall getRightDisjunctionParserRuleCall_1_1_0() { return cRightDisjunctionParserRuleCall_1_1_0; }
	}

	public class ConjunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Conjunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNegationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightConjunctionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Conjunction returns LExpression:
		//
		//	Negation ({And.left=current} "and" right=Conjunction)?;
		public ParserRule getRule() { return rule; }

		//Negation ({And.left=current} "and" right=Conjunction)?
		public Group getGroup() { return cGroup; }

		//Negation
		public RuleCall getNegationParserRuleCall_0() { return cNegationParserRuleCall_0; }

		//({And.left=current} "and" right=Conjunction)?
		public Group getGroup_1() { return cGroup_1; }

		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }

		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }

		//right=Conjunction
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Conjunction
		public RuleCall getRightConjunctionParserRuleCall_1_2_0() { return cRightConjunctionParserRuleCall_1_2_0; }
	}

	public class NegationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Negation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cNegatedParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cCExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Negation returns LExpression:
		//
		//	"not" Negated | CExpression;
		public ParserRule getRule() { return rule; }

		//"not" Negated | CExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//"not" Negated
		public Group getGroup_0() { return cGroup_0; }

		//"not"
		public Keyword getNotKeyword_0_0() { return cNotKeyword_0_0; }

		//Negated
		public RuleCall getNegatedParserRuleCall_0_1() { return cNegatedParserRuleCall_0_1; }

		//CExpression
		public RuleCall getCExpressionParserRuleCall_1() { return cCExpressionParserRuleCall_1; }
	}

	public class NegatedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Negated");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNotAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNotCExpressionParserRuleCall_1_0 = (RuleCall)cNotAssignment_1.eContents().get(0);
		
		//Negated returns LExpression:
		//
		//	{Not} not=CExpression;
		public ParserRule getRule() { return rule; }

		//{Not} not=CExpression
		public Group getGroup() { return cGroup; }

		//{Not}
		public Action getNotAction_0() { return cNotAction_0; }

		//not=CExpression
		public Assignment getNotAssignment_1() { return cNotAssignment_1; }

		//CExpression
		public RuleCall getNotCExpressionParserRuleCall_1_0() { return cNotCExpressionParserRuleCall_1_0; }
	}

	public class CExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cLExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cCompareParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVariableParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// Compare Layer   ------------------------------------------------
		//
		//CExpression returns LExpression:
		//
		//	"(" LExpression ")" | Compare | BooleanValue | Variable;
		public ParserRule getRule() { return rule; }

		//"(" LExpression ")" | Compare | BooleanValue | Variable
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" LExpression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//LExpression
		public RuleCall getLExpressionParserRuleCall_0_1() { return cLExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//Compare
		public RuleCall getCompareParserRuleCall_1() { return cCompareParserRuleCall_1; }

		//BooleanValue
		public RuleCall getBooleanValueParserRuleCall_2() { return cBooleanValueParserRuleCall_2; }

		//Variable
		public RuleCall getVariableParserRuleCall_3() { return cVariableParserRuleCall_3; }
	}

	public class CompareElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Compare");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSomeValueParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cLessOrEqualLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cLessLeftAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cGreaterOrEqualLeftAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Group cGroup_1_3 = (Group)cAlternatives_1.eContents().get(3);
		private final Action cGreaterLeftAction_1_3_0 = (Action)cGroup_1_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_3_1 = (Keyword)cGroup_1_3.eContents().get(1);
		private final Group cGroup_1_4 = (Group)cAlternatives_1.eContents().get(4);
		private final Action cEqualLeftAction_1_4_0 = (Action)cGroup_1_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_4_1 = (Keyword)cGroup_1_4.eContents().get(1);
		private final Group cGroup_1_5 = (Group)cAlternatives_1.eContents().get(5);
		private final Action cUnequalLeftAction_1_5_0 = (Action)cGroup_1_5.eContents().get(0);
		private final Keyword cExclamationMarkEqualsSignKeyword_1_5_1 = (Keyword)cGroup_1_5.eContents().get(1);
		private final Group cGroup_1_6 = (Group)cAlternatives_1.eContents().get(6);
		private final Action cApproxLeftAction_1_6_0 = (Action)cGroup_1_6.eContents().get(0);
		private final Keyword cTildeKeyword_1_6_1 = (Keyword)cGroup_1_6.eContents().get(1);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightSomeValueParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//Compare returns CExpression:
		//
		//	SomeValue ({LessOrEqual.left=current} "<=" | {Less.left=current} "<" | {GreaterOrEqual.left=current} ">=" |
		//
		//	{Greater.left=current} ">" | {Equal.left=current} "=" | {Unequal.left=current} "!=" | {Approx.left=current} "~")
		//
		//	right=SomeValue;
		public ParserRule getRule() { return rule; }

		//SomeValue ({LessOrEqual.left=current} "<=" | {Less.left=current} "<" | {GreaterOrEqual.left=current} ">=" |
		//
		//{Greater.left=current} ">" | {Equal.left=current} "=" | {Unequal.left=current} "!=" | {Approx.left=current} "~")
		//
		//right=SomeValue
		public Group getGroup() { return cGroup; }

		//SomeValue
		public RuleCall getSomeValueParserRuleCall_0() { return cSomeValueParserRuleCall_0; }

		//{LessOrEqual.left=current} "<=" | {Less.left=current} "<" | {GreaterOrEqual.left=current} ">=" | {Greater.left=current}
		//
		//">" | {Equal.left=current} "=" | {Unequal.left=current} "!=" | {Approx.left=current} "~"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{LessOrEqual.left=current} "<="
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{LessOrEqual.left=current}
		public Action getLessOrEqualLeftAction_1_0_0() { return cLessOrEqualLeftAction_1_0_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_1() { return cLessThanSignEqualsSignKeyword_1_0_1; }

		//{Less.left=current} "<"
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{Less.left=current}
		public Action getLessLeftAction_1_1_0() { return cLessLeftAction_1_1_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1_1_1() { return cLessThanSignKeyword_1_1_1; }

		//{GreaterOrEqual.left=current} ">="
		public Group getGroup_1_2() { return cGroup_1_2; }

		//{GreaterOrEqual.left=current}
		public Action getGreaterOrEqualLeftAction_1_2_0() { return cGreaterOrEqualLeftAction_1_2_0; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_2_1() { return cGreaterThanSignEqualsSignKeyword_1_2_1; }

		//{Greater.left=current} ">"
		public Group getGroup_1_3() { return cGroup_1_3; }

		//{Greater.left=current}
		public Action getGreaterLeftAction_1_3_0() { return cGreaterLeftAction_1_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_3_1() { return cGreaterThanSignKeyword_1_3_1; }

		//{Equal.left=current} "="
		public Group getGroup_1_4() { return cGroup_1_4; }

		//{Equal.left=current}
		public Action getEqualLeftAction_1_4_0() { return cEqualLeftAction_1_4_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_4_1() { return cEqualsSignKeyword_1_4_1; }

		//{Unequal.left=current} "!="
		public Group getGroup_1_5() { return cGroup_1_5; }

		//{Unequal.left=current}
		public Action getUnequalLeftAction_1_5_0() { return cUnequalLeftAction_1_5_0; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1_5_1() { return cExclamationMarkEqualsSignKeyword_1_5_1; }

		//{Approx.left=current} "~"
		public Group getGroup_1_6() { return cGroup_1_6; }

		//{Approx.left=current}
		public Action getApproxLeftAction_1_6_0() { return cApproxLeftAction_1_6_0; }

		//"~"
		public Keyword getTildeKeyword_1_6_1() { return cTildeKeyword_1_6_1; }

		//right=SomeValue
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//SomeValue
		public RuleCall getRightSomeValueParserRuleCall_2_0() { return cRightSomeValueParserRuleCall_2_0; }
	}

	public class SomeValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SomeValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStringValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanValueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//SomeValue:
		//
		//	StringValue | BooleanValue | AExpression;
		public ParserRule getRule() { return rule; }

		//StringValue | BooleanValue | AExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//StringValue
		public RuleCall getStringValueParserRuleCall_0() { return cStringValueParserRuleCall_0; }

		//BooleanValue
		public RuleCall getBooleanValueParserRuleCall_1() { return cBooleanValueParserRuleCall_1; }

		//AExpression
		public RuleCall getAExpressionParserRuleCall_2() { return cAExpressionParserRuleCall_2; }
	}

	public class AExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AExpression");
		private final RuleCall cAdditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Arithmetic Layer   ------------------------------------------------
		//
		//AExpression:
		//
		//	Addition;
		public ParserRule getRule() { return rule; }

		//Addition
		public RuleCall getAdditionParserRuleCall() { return cAdditionParserRuleCall; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cPlusLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMultiplicationParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Addition returns AExpression:
		//
		//	Multiplication (({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*;
		public ParserRule getRule() { return rule; }

		//Multiplication (({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//(({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Plus.left=current} "+" | {Minus.left=current} "-"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Plus.left=current} "+"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Plus.left=current}
		public Action getPlusLeftAction_1_0_0_0() { return cPlusLeftAction_1_0_0_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }

		//{Minus.left=current} "-"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Minus.left=current}
		public Action getMinusLeftAction_1_0_1_0() { return cMinusLeftAction_1_0_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }

		//right=Multiplication
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_1_0() { return cRightMultiplicationParserRuleCall_1_1_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPowerParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMultiLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cModLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cPercentSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPowerParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Multiplication returns AExpression:
		//
		//	Power (({Multi.left=current} "*" | {Div.left=current} "/" | {Mod.left=current} "%") right=Power)*;
		public ParserRule getRule() { return rule; }

		//Power (({Multi.left=current} "*" | {Div.left=current} "/" | {Mod.left=current} "%") right=Power)*
		public Group getGroup() { return cGroup; }

		//Power
		public RuleCall getPowerParserRuleCall_0() { return cPowerParserRuleCall_0; }

		//(({Multi.left=current} "*" | {Div.left=current} "/" | {Mod.left=current} "%") right=Power)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multi.left=current} "*" | {Div.left=current} "/" | {Mod.left=current} "%"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Multi.left=current} "*"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Multi.left=current}
		public Action getMultiLeftAction_1_0_0_0() { return cMultiLeftAction_1_0_0_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_0_0_1() { return cAsteriskKeyword_1_0_0_1; }

		//{Div.left=current} "/"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Div.left=current}
		public Action getDivLeftAction_1_0_1_0() { return cDivLeftAction_1_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1_0_1_1() { return cSolidusKeyword_1_0_1_1; }

		//{Mod.left=current} "%"
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{Mod.left=current}
		public Action getModLeftAction_1_0_2_0() { return cModLeftAction_1_0_2_0; }

		//"%"
		public Keyword getPercentSignKeyword_1_0_2_1() { return cPercentSignKeyword_1_0_2_1; }

		//right=Power
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Power
		public RuleCall getRightPowerParserRuleCall_1_1_0() { return cRightPowerParserRuleCall_1_1_0; }
	}

	public class PowerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Power");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cPowLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPrimaryExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Power returns AExpression:
		//
		//	PrimaryExpression (({Pow.left=current} "^") right=PrimaryExpression)*;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression (({Pow.left=current} "^") right=PrimaryExpression)*
		public Group getGroup() { return cGroup; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//(({Pow.left=current} "^") right=PrimaryExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{Pow.left=current} "^"
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{Pow.left=current}
		public Action getPowLeftAction_1_0_0() { return cPowLeftAction_1_0_0; }

		//"^"
		public Keyword getCircumflexAccentKeyword_1_0_1() { return cCircumflexAccentKeyword_1_0_1; }

		//right=PrimaryExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//PrimaryExpression
		public RuleCall getRightPrimaryExpressionParserRuleCall_1_1_0() { return cRightPrimaryExpressionParserRuleCall_1_1_0; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cAExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cNumberValueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVariableParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PrimaryExpression returns AExpression:
		//
		//	"(" AExpression ")" | NumberValue | Variable;
		public ParserRule getRule() { return rule; }

		//"(" AExpression ")" | NumberValue | Variable
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" AExpression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//AExpression
		public RuleCall getAExpressionParserRuleCall_0_1() { return cAExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//NumberValue
		public RuleCall getNumberValueParserRuleCall_1() { return cNumberValueParserRuleCall_1; }

		//Variable
		public RuleCall getVariableParserRuleCall_2() { return cVariableParserRuleCall_2; }
	}

	public class NumberValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumberValue");
		private final Assignment cNumValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNumValueNUMBERParserRuleCall_0 = (RuleCall)cNumValueAssignment.eContents().get(0);
		
		//NumberValue:
		//
		//	numValue=NUMBER;
		public ParserRule getRule() { return rule; }

		//numValue=NUMBER
		public Assignment getNumValueAssignment() { return cNumValueAssignment; }

		//NUMBER
		public RuleCall getNumValueNUMBERParserRuleCall_0() { return cNumValueNUMBERParserRuleCall_0; }
	}

	public class NUMBERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//NUMBER returns EInt:
		//
		//	INT ("." INT)?;
		public ParserRule getRule() { return rule; }

		//INT ("." INT)?
		public Group getGroup() { return cGroup; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//("." INT)?
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }
	}

	public class BooleanValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEANTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BooleanValue:
		//
		//	value=BOOLEAN;
		public ParserRule getRule() { return rule; }

		//value=BOOLEAN
		public Assignment getValueAssignment() { return cValueAssignment; }

		//BOOLEAN
		public RuleCall getValueBOOLEANTerminalRuleCall_0() { return cValueBOOLEANTerminalRuleCall_0; }
	}

	public class StringValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringValue");
		private final Assignment cStrValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStrValueSTRINGTerminalRuleCall_0 = (RuleCall)cStrValueAssignment.eContents().get(0);
		
		//StringValue:
		//
		//	strValue=STRING;
		public ParserRule getRule() { return rule; }

		//strValue=STRING
		public Assignment getStrValueAssignment() { return cStrValueAssignment; }

		//STRING
		public RuleCall getStrValueSTRINGTerminalRuleCall_0() { return cStrValueSTRINGTerminalRuleCall_0; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Variable");
		private final Assignment cVarNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cVarNameVARIABLE_VALUEParserRuleCall_0 = (RuleCall)cVarNameAssignment.eContents().get(0);
		
		//Variable:
		//
		//	varName=VARIABLE_VALUE;
		public ParserRule getRule() { return rule; }

		//varName=VARIABLE_VALUE
		public Assignment getVarNameAssignment() { return cVarNameAssignment; }

		//VARIABLE_VALUE
		public RuleCall getVarNameVARIABLE_VALUEParserRuleCall_0() { return cVarNameVARIABLE_VALUEParserRuleCall_0; }
	}

	public class VARIABLE_VALUEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VARIABLE_VALUE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//VARIABLE_VALUE returns EString:
		//
		//	ID | ID "." ID;
		public ParserRule getRule() { return rule; }

		//ID | ID "." ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//ID "." ID
		public Group getGroup_1() { return cGroup_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_0() { return cIDTerminalRuleCall_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_2() { return cIDTerminalRuleCall_1_2; }
	}
	
	
	private ExpressionElements pExpression;
	private LExpressionElements pLExpression;
	private EquivalentElements pEquivalent;
	private ImplicationElements pImplication;
	private DisjunctionElements pDisjunction;
	private ConjunctionElements pConjunction;
	private NegationElements pNegation;
	private NegatedElements pNegated;
	private CExpressionElements pCExpression;
	private CompareElements pCompare;
	private SomeValueElements pSomeValue;
	private AExpressionElements pAExpression;
	private AdditionElements pAddition;
	private MultiplicationElements pMultiplication;
	private PowerElements pPower;
	private PrimaryExpressionElements pPrimaryExpression;
	private NumberValueElements pNumberValue;
	private NUMBERElements pNUMBER;
	private BooleanValueElements pBooleanValue;
	private TerminalRule tBOOLEAN;
	private StringValueElements pStringValue;
	private VariableElements pVariable;
	private VARIABLE_VALUEElements pVARIABLE_VALUE;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public ExpressionsGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.upb.lina.lll.Expressions".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/// *
	//
	// * Once, I wrote this in the context of story diagram meta-models. As it is no longer supported there,
	//
	// * I am going to maintain it within this project. 
	//
	// * Oleg 
	//
	// * / // Boolean Logic Layer    ------------------------------------------------
	//
	//Expression:
	//
	//	LExpression | AExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//LExpression:
	//
	//	Equivalent;
	public LExpressionElements getLExpressionAccess() {
		return (pLExpression != null) ? pLExpression : (pLExpression = new LExpressionElements());
	}
	
	public ParserRule getLExpressionRule() {
		return getLExpressionAccess().getRule();
	}

	//Equivalent returns LExpression:
	//
	//	Implication ({Equivalent.left=current} "equiv" right=Equivalent)?;
	public EquivalentElements getEquivalentAccess() {
		return (pEquivalent != null) ? pEquivalent : (pEquivalent = new EquivalentElements());
	}
	
	public ParserRule getEquivalentRule() {
		return getEquivalentAccess().getRule();
	}

	//Implication returns LExpression:
	//
	//	Disjunction ({Imply.left=current} "imply" right=Implication)?;
	public ImplicationElements getImplicationAccess() {
		return (pImplication != null) ? pImplication : (pImplication = new ImplicationElements());
	}
	
	public ParserRule getImplicationRule() {
		return getImplicationAccess().getRule();
	}

	//Disjunction returns LExpression:
	//
	//	Conjunction (({Or.left=current} "or" | {Xor.left=current} "xor") right=Disjunction)?;
	public DisjunctionElements getDisjunctionAccess() {
		return (pDisjunction != null) ? pDisjunction : (pDisjunction = new DisjunctionElements());
	}
	
	public ParserRule getDisjunctionRule() {
		return getDisjunctionAccess().getRule();
	}

	//Conjunction returns LExpression:
	//
	//	Negation ({And.left=current} "and" right=Conjunction)?;
	public ConjunctionElements getConjunctionAccess() {
		return (pConjunction != null) ? pConjunction : (pConjunction = new ConjunctionElements());
	}
	
	public ParserRule getConjunctionRule() {
		return getConjunctionAccess().getRule();
	}

	//Negation returns LExpression:
	//
	//	"not" Negated | CExpression;
	public NegationElements getNegationAccess() {
		return (pNegation != null) ? pNegation : (pNegation = new NegationElements());
	}
	
	public ParserRule getNegationRule() {
		return getNegationAccess().getRule();
	}

	//Negated returns LExpression:
	//
	//	{Not} not=CExpression;
	public NegatedElements getNegatedAccess() {
		return (pNegated != null) ? pNegated : (pNegated = new NegatedElements());
	}
	
	public ParserRule getNegatedRule() {
		return getNegatedAccess().getRule();
	}

	//// Compare Layer   ------------------------------------------------
	//
	//CExpression returns LExpression:
	//
	//	"(" LExpression ")" | Compare | BooleanValue | Variable;
	public CExpressionElements getCExpressionAccess() {
		return (pCExpression != null) ? pCExpression : (pCExpression = new CExpressionElements());
	}
	
	public ParserRule getCExpressionRule() {
		return getCExpressionAccess().getRule();
	}

	//Compare returns CExpression:
	//
	//	SomeValue ({LessOrEqual.left=current} "<=" | {Less.left=current} "<" | {GreaterOrEqual.left=current} ">=" |
	//
	//	{Greater.left=current} ">" | {Equal.left=current} "=" | {Unequal.left=current} "!=" | {Approx.left=current} "~")
	//
	//	right=SomeValue;
	public CompareElements getCompareAccess() {
		return (pCompare != null) ? pCompare : (pCompare = new CompareElements());
	}
	
	public ParserRule getCompareRule() {
		return getCompareAccess().getRule();
	}

	//SomeValue:
	//
	//	StringValue | BooleanValue | AExpression;
	public SomeValueElements getSomeValueAccess() {
		return (pSomeValue != null) ? pSomeValue : (pSomeValue = new SomeValueElements());
	}
	
	public ParserRule getSomeValueRule() {
		return getSomeValueAccess().getRule();
	}

	//// Arithmetic Layer   ------------------------------------------------
	//
	//AExpression:
	//
	//	Addition;
	public AExpressionElements getAExpressionAccess() {
		return (pAExpression != null) ? pAExpression : (pAExpression = new AExpressionElements());
	}
	
	public ParserRule getAExpressionRule() {
		return getAExpressionAccess().getRule();
	}

	//Addition returns AExpression:
	//
	//	Multiplication (({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return (pAddition != null) ? pAddition : (pAddition = new AdditionElements());
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication returns AExpression:
	//
	//	Power (({Multi.left=current} "*" | {Div.left=current} "/" | {Mod.left=current} "%") right=Power)*;
	public MultiplicationElements getMultiplicationAccess() {
		return (pMultiplication != null) ? pMultiplication : (pMultiplication = new MultiplicationElements());
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//Power returns AExpression:
	//
	//	PrimaryExpression (({Pow.left=current} "^") right=PrimaryExpression)*;
	public PowerElements getPowerAccess() {
		return (pPower != null) ? pPower : (pPower = new PowerElements());
	}
	
	public ParserRule getPowerRule() {
		return getPowerAccess().getRule();
	}

	//PrimaryExpression returns AExpression:
	//
	//	"(" AExpression ")" | NumberValue | Variable;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//NumberValue:
	//
	//	numValue=NUMBER;
	public NumberValueElements getNumberValueAccess() {
		return (pNumberValue != null) ? pNumberValue : (pNumberValue = new NumberValueElements());
	}
	
	public ParserRule getNumberValueRule() {
		return getNumberValueAccess().getRule();
	}

	//NUMBER returns EInt:
	//
	//	INT ("." INT)?;
	public NUMBERElements getNUMBERAccess() {
		return (pNUMBER != null) ? pNUMBER : (pNUMBER = new NUMBERElements());
	}
	
	public ParserRule getNUMBERRule() {
		return getNUMBERAccess().getRule();
	}

	//BooleanValue:
	//
	//	value=BOOLEAN;
	public BooleanValueElements getBooleanValueAccess() {
		return (pBooleanValue != null) ? pBooleanValue : (pBooleanValue = new BooleanValueElements());
	}
	
	public ParserRule getBooleanValueRule() {
		return getBooleanValueAccess().getRule();
	}

	//terminal BOOLEAN returns EBoolean:
	//
	//	"true" | "false";
	public TerminalRule getBOOLEANRule() {
		return (tBOOLEAN != null) ? tBOOLEAN : (tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN"));
	} 

	//StringValue:
	//
	//	strValue=STRING;
	public StringValueElements getStringValueAccess() {
		return (pStringValue != null) ? pStringValue : (pStringValue = new StringValueElements());
	}
	
	public ParserRule getStringValueRule() {
		return getStringValueAccess().getRule();
	}

	//Variable:
	//
	//	varName=VARIABLE_VALUE;
	public VariableElements getVariableAccess() {
		return (pVariable != null) ? pVariable : (pVariable = new VariableElements());
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//VARIABLE_VALUE returns EString:
	//
	//	ID | ID "." ID;
	public VARIABLE_VALUEElements getVARIABLE_VALUEAccess() {
		return (pVARIABLE_VALUE != null) ? pVARIABLE_VALUE : (pVARIABLE_VALUE = new VARIABLE_VALUEElements());
	}
	
	public ParserRule getVARIABLE_VALUERule() {
		return getVARIABLE_VALUEAccess().getRule();
	}

	//terminal ID:
	//
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
